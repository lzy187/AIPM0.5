# 智能问答模块设计（优化版）

## 模块概述
智能问答模块通过AI分析对话历史，基于PRD生成需求精准收集关键信息，采用动态气泡交互，为AI Coding场景量身定制，弱化商业论证，强化功能实现。

## 核心设计原则

### ✅ **AI智能分析对话历史**
- 避免重复询问显而易见的信息

### ✅ **基于PRD需求精准收集信息**
- 问题直接对应PRD生成所需的核心信息
- 避免商业背景、竞品分析等传统PRD内容
- 强化功能实现相关信息收集

### ✅ **基于信息完整性的智能问答策略**
- 动态评估需求信息的完整性，智能决定是否继续提问
- 根据关键信息、重要信息、可选信息的缺失程度调整问题策略
- 避免硬编码问题数量，基于实际需要生成问题

### ✅ **面向AI Coding场景优化**
- 弱化传统PRD的商业论证部分
- 强化技术实现和功能细节收集
- 适合"用Cursor制作提效工具"的使用场景

## 📋 信息收集策略设计

### 1. 基于PRD需求的信息映射

```typescript
// 根据优化的PRD结构，反推必需信息
interface PRDRequiredInfo {
  // 产品定义（生成productOverview）
  productDefinition: {
    type: string;           // 产品类型 - 从用户描述推断
    coreGoal: string;       // 核心目标 - 用户原话
    targetUsers: string;    // 目标用户 - 简单描述
    useScenarios: string[]; // 使用场景 - 何时何时使用
  };

  // 功能需求（生成functionalRequirements）
  functionalRequirements: {
    coreFeatures: string[];     // 核心功能清单
    userJourney: string;        // 用户操作流程
    inputOutput: string;        // 输入输出描述
    dataHandling?: string;      // 数据处理方式（如需要）
    integrationNeeds?: string[]; // 集成需求（如需要）
  };

  // 技术约束（生成technicalSpecs）
  technicalConstraints: {
    complexity: 'simple' | 'moderate' | 'complex'; // 复杂度
    platformHints?: string;     // 平台线索
    performanceNeeds?: string;  // 性能要求
  };

  // 上下文信息（优化PRD质量）
  contextInfo: {
    painPoints: string[];       // 用户痛点
    currentSolution?: string;   // 现有解决方案
    successCriteria?: string;   // 成功标准
  };
}
```

### 2. 智能信息提取引擎

```typescript
class SmartInfoExtractor {
  async analyzeConversation(messages: ConversationMessage[]): Promise<ExtractionResult> {
    const prompt = `
你是AI产品经理助手，分析对话提取PRD生成所需信息。

对话历史：
${messages.map(m => `${m.role}: ${m.content}`).join('
')}

任务：
1. 提取已明确的信息，标记置信度
2. 识别生成PRD还缺少的关键信息
3. 生成1-3个精准问题收集缺失信息
4. 避免商业背景、竞品分析等问题

PRD生成核心信息需求：
【产品定义】
- 产品类型（从描述推断，如：浏览器插件、Web工具、管理系统）
- 核心目标（用户想解决什么问题，用用户的语言）
- 目标用户（谁使用：个人/小团队/公众）
- 使用场景（什么时候、什么情况下使用）

【功能需求】
- 核心功能清单（3-5个主要功能）
- 用户操作流程（从开始到结束的步骤）
- 输入输出（用户输入什么，得到什么结果）
- 数据处理（如何处理数据，是否需要保存）

【实现约束】
- 技术复杂度（从功能推断：简单/中等/复杂）
- 性能要求（如有明确需求）

绝对不要询问的内容：
❌ 业务背景、商业模式
❌ 竞品分析、市场调研
❌ 运营策略、推广方案
❌ ROI、商业价值论证
❌ 项目管理、团队组织
❌ 具体技术栈选择（这是AI Coding阶段的事）

响应格式（JSON）：
`

    return await this.aiClient.chatCompletion([
      { role: 'system', content: prompt },
      { role: 'user', content: '请分析对话并生成信息提取结果' },
    ])
  }
}
```

### 3. 产品类型自适应问题库

```typescript
// 基于产品类型的精准问题策略
const SMART_QUESTIONS_BY_TYPE = {
  'browser_extension': {
    criticalInfo: ['triggerMechanism', 'dataHandling', 'permissions'],
    smartQuestions: [
      {
        condition: 'missing_trigger_mechanism',
        question: '插件什么时候开始工作？',
        type: 'choice',
        options: [
          '打开特定网页时自动运行',
          '用户点击插件图标时运行',
          '用户选中内容后右键运行',
          '在后台持续监控',
        ],
        purpose: 'determine_user_flow',
      },
      {
        condition: 'missing_data_handling',
        question: '处理的数据需要保存吗？',
        type: 'choice',
        options: [
          '不保存，直接使用',
          '保存到本地供下载',
          '保存设置和历史记录',
          '同步到云端',
        ],
        purpose: 'determine_data_requirements',
      },
    ]
  },
  'utility_tool': {
    criticalInfo: ['inputOutput', 'processFlow', 'usageFrequency'],
    smartQuestions: [
      {
        condition: 'missing_input_output',
        question: '用户需要输入什么，会得到什么？',
        type: 'text',
        placeholder: '例如：输入一段文本，输出统计分析结果',
        purpose: 'define_core_functionality',
      },
      {
        condition: 'missing_process_flow',
        question: '用户使用这个工具的完整流程是？',
        type: 'text',
        placeholder: '例如：上传文件 → 选择处理方式 → 点击开始 → 下载结果',
        purpose: 'define_user_journey',
      },
    ]
  },
  'management_tool': {
    criticalInfo: ['userRoles', 'dataStructure', 'workflow', 'collaboration'],
    smartQuestions: [
      {
        condition: 'missing_user_roles',
        question: '会有多少人使用这个工具？',
        type: 'choice',
        options: [
          '只有我自己',
          '我和2-5个同事',
          '整个团队(6-20人)',
          '更大规模的组织',
        ],
        purpose: 'determine_collaboration_needs',
      },
      {
        condition: 'missing_workflow',
        question: '典型的管理流程是什么样的？',
        type: 'text',
        placeholder: '例如：创建任务 → 分配责任人 → 跟踪进度 → 标记完成',
        purpose: 'define_management_workflow',
      },
    ]
  },
  'web_app': {
    criticalInfo: ['userScope', 'coreFeatures', 'dataModel'],
    smartQuestions: [
      {
        condition: 'missing_user_scope',
        question: '这个应用主要给谁使用？',
        type: 'choice',
        options: [
          '我个人使用',
          '我和团队使用',
          '对外提供给用户使用',
          '不确定，看情况',
        ],
        purpose: 'determine_user_scope_and_features',
      },
    ]
  }
}
```

### 4. 智能问题选择算法

```typescript
class SmartQuestionSelector {
  selectOptimalQuestions(
    extractedInfo: ExtractedInfo,
    productType: string,
    conversationLength: number
  ): Question[] {
    const productConfig = SMART_QUESTIONS_BY_TYPE[productType] || SMART_QUESTIONS_BY_TYPE['utility_tool']
    // 1. 基于缺失的关键信息选择问题
    const missingInfo = this.identifyMissingCriticalInfo(extractedInfo, productConfig.criticalInfo)
    // 2. 根据对话长度调整问题数量
    const maxQuestions = this.getMaxQuestions(conversationLength, productType)
    // 3. 按优先级选择问题
    const selectedQuestions = missingInfo
      .slice(0, maxQuestions)
      .map(infoType => this.findQuestionByType(productConfig, infoType))
      .filter(Boolean)
    return selectedQuestions
  }

  private shouldContinueQuestioning(
    extractedInfo: ExtractedInfo,
    conversationLength: number,
    currentCompleteness: InformationCompleteness
  ): boolean {
    // 1. 防止过度询问的安全限制
    if (conversationLength >= 8) return false; // 最多8轮对话

    // 2. 基于信息完整性智能判断
    const criticalComplete = this.evaluateCriticalInfoCompleteness(extractedInfo);
    const importantComplete = this.evaluateImportantInfoCompleteness(extractedInfo);

    // 3. 关键信息不足，必须继续
    if (criticalComplete < 0.85) return true;

    // 4. 重要信息不足且对话较少，可以继续
    if (importantComplete < 0.75 && conversationLength < 5) return true;

    // 5. 整体完整性不足且刚开始，可以继续
    if (currentCompleteness.overall < 0.8 && conversationLength < 3) return true;

    // 6. 其他情况停止问答
    return false;
  }

  private evaluateCriticalInfoCompleteness(extractedInfo: ExtractedInfo): number {
    const criticalFields = [
      'productType',    // 产品类型
      'coreGoal',       // 核心目标
      'targetUsers',    // 目标用户
      'coreFeatures'    // 核心功能
    ];

    let completedCount = 0;
    let totalWeight = 0;

    for (const field of criticalFields) {
      totalWeight += 1;
      if (this.isFieldComplete(extractedInfo[field])) {
        completedCount += 1;
      }
    }

    return completedCount / totalWeight;
  }

  private evaluateImportantInfoCompleteness(extractedInfo: ExtractedInfo): number {
    const importantFields = [
      'useScenario',     // 使用场景
      'inputOutput',     // 输入输出
      'userJourney',     // 用户流程
      'painPoint'        // 痛点
    ];

    let completedCount = 0;
    let totalWeight = 0;

    for (const field of importantFields) {
      totalWeight += 1;
      if (this.isFieldComplete(extractedInfo[field])) {
        completedCount += 1;
      }
    }

    return completedCount / totalWeight;
  }

  private isFieldComplete(fieldValue: any): boolean {
    if (!fieldValue) return false;
    if (typeof fieldValue === 'string') {
      return fieldValue.trim().length > 5; // 至少5个字符
    }
    if (Array.isArray(fieldValue)) {
      return fieldValue.length > 0 && fieldValue.every(item =>
        typeof item === 'string' ? item.trim().length > 3 : true
      );
    }
    return true;
  }

  private identifyMissingCriticalInfo(extractedInfo: ExtractedInfo, criticalInfoTypes: string[]): string[] {
    const missing = []
    for (const infoType of criticalInfoTypes) {
      if (!this.hasRequiredInfo(extractedInfo, infoType)) {
        missing.push(infoType)
      }
    }
    return missing.sort((a, b) => this.getInfoPriority(a) - this.getInfoPriority(b))
  }

  private hasRequiredInfo(extractedInfo: ExtractedInfo, infoType: string): boolean {
    const checkers = {
      'triggerMechanism': () => extractedInfo.userJourney && extractedInfo.userJourney.includes('触发'),
      'dataHandling': () => extractedInfo.dataHandling || extractedInfo.inputOutput?.includes('保存'),
      'inputOutput': () => extractedInfo.inputOutput && extractedInfo.inputOutput.length > 10,
      'processFlow': () => extractedInfo.userJourney && extractedInfo.userJourney.includes('→'),
      'userRoles': () => extractedInfo.targetUsers && !extractedInfo.targetUsers.includes('用户'),
      'workflow': () => extractedInfo.userJourney && extractedInfo.userJourney.includes('流程'),
      'userScope': () => extractedInfo.userScope && extractedInfo.userScope !== 'unknown',
    }
    return checkers[infoType]?.() || false
  }

  private async generateCandidateQuestions(
    sessionState: SessionState,
    slotPriorities: SlotPriority[]
  ): Promise<Question[]> {
    const questions: Question[] = []
    const userScope = this.determineUserScope(sessionState.extractedInfo)
    // 为每个高优先级槽位生成问题
    for (const slotPriority of slotPriorities.slice(0, 8)) {
      const slot = sessionState.slotStates.find(s => s.slotId === slotPriority.slotId)
      if (!slot) continue
      if (slot.isAmbiguous) {
        // 生成消歧问题
        questions.push(...await this.generateDisambiguationQuestions(slot, sessionState))
      } else if (slot.confidence < 0.7) {
        // 生成信息收集问题
        questions.push(...await this.generateInformationGatheringQuestions(slot, userScope, sessionState))
      }
    }
    return questions
  }

  private async generateInformationGatheringQuestions(
    slot: SlotState,
    userScope: string,
    sessionState: SessionState
  ): Promise<Question[]> {
    const questionTemplates = {
      'product_type': {
        personal: {
          question: '这个工具主要解决什么类型的问题？',
          options: [
            { id: 'automation', text: '自动化处理（减少手动操作）' },
            { id: 'information', text: '信息整理（收集、管理数据）' },
            { id: 'productivity', text: '效率提升（简化工作流程）' },
            { id: 'analysis', text: '分析计算（处理复杂逻辑）' },
          ]
        },
        team: {
          question: '团队主要用这个工具来做什么？',
          options: [
            { id: 'collaboration', text: '协作沟通（团队协作）' },
            { id: 'management', text: '项目管理（任务分配、进度跟踪）' },
            { id: 'knowledge', text: '知识管理（文档、经验分享）' },
            { id: 'workflow', text: '工作流程（标准化流程）' },
          ]
        },
      },
      'frequency': {
        question: '您预计多久使用一次？',
        options: [
          { id: 'daily', text: '每天都用' },
          { id: 'weekly', text: '每周几次' },
          { id: 'monthly', text: '每月几次' },
          { id: 'occasional', text: '偶尔使用' },
        ]
      },
      'use_scenario': {
        question: '能简单描述一下典型的使用场景吗？',
        type: 'text_simple',
        placeholder: '例如：每天早上查看任务列表，处理优先级高的事项...',
      }
    }
    const template = questionTemplates[slot.slotId]
    if (!template) return []
    const questionData = typeof template === 'object' && template[userScope]
      ? template[userScope]
      : template
    return [
      {
        id: `${slot.slotId}_${Date.now()}`,
        question: questionData.question,
        type: questionData.type || 'single_choice',
        targetSlots: [slot.slotId],
        options: questionData.options,
        placeholder: questionData.placeholder,
        priority: this.calculateInformationGain(slot, sessionState),
        adaptiveLevel: userScope as any
      }
    ]
  }
}
```

### 5. 产品类型自适应问题库

```typescript
const ADAPTIVE_QUESTION_SETS = {
  // 个人小工具 - 最简化问题
  personal_tool: {
    maxQuestions: 2,
    questions: [
      {
        id: 'usage_frequency',
        question: '您大概多久会使用一次这个工具？',
        type: 'single_choice',
        options: [
          { id: 'daily', text: '每天都用', score: 3 },
          { id: 'weekly', text: '每周几次', score: 2 },
          { id: 'occasional', text: '偶尔使用', score: 1 },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.frequency
      },
      {
        id: 'data_persistence',
        question: '需要保存您的使用记录或设置吗？',
        type: 'single_choice',
        options: [
          { id: 'no_save', text: '不需要，每次重新开始' },
          { id: 'basic_save', text: '保存基本设置' },
          { id: 'full_history', text: '保存完整使用历史' },
        ],
        relevanceCheck: (info: ExtractedInfo) => {
          !info.coreFeatures?.some(f => f.includes('保存') || f.includes('记录'))
        }
      }
    ]
  },
  // 小团队工具 - 中等复杂度
  small_team_tool: {
    maxQuestions: 3,
    questions: [
      {
        id: 'team_size',
        question: '您的团队大概有多少人？',
        type: 'single_choice',
        options: [
          { id: 'small', text: '2-5人' },
          { id: 'medium', text: '6-15人' },
          { id: 'large', text: '16人以上' },
        ],
        relevanceCheck: (info: ExtractedInfo) => info.userScope === 'small_team' && !info.targetUsers?.match(/\d+人/)
      },
      {
        id: 'collaboration_level',
        question: '团队成员之间需要协作吗？',
        type: 'single_choice',
        options: [
          { id: 'independent', text: '各自独立使用' },
          { id: 'share_data', text: '需要共享数据' },
          { id: 'real_time', text: '需要实时协作' },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.coreFeatures?.some(f => {
          f.includes('协作') || f.includes('共享') || f.includes('同步')
        })
      },
      {
        id: 'workflow_steps',
        question: '能简单说说团队使用这个工具的流程吗？',
        type: 'text_simple',
        placeholder: '例如：创建任务 → 分配给成员 → 更新进度 → 完成确认',
        relevanceCheck: (info: ExtractedInfo) => !info.useScenario
      }
    ]
  },
  // 公众产品 - 相对全面
  public_product: {
    maxQuestions: 4,
    questions: [
      {
        id: 'user_base_expectation',
        question: '您希望有多少人使用这个产品？',
        type: 'single_choice',
        options: [
          { id: 'hundreds', text: '几百人' },
          { id: 'thousands', text: '几千人' },
          { id: 'more', text: '上万人' },
          { id: 'unknown', text: '不确定，看情况' },
        ],
        relevanceCheck: (info: ExtractedInfo) => info.userScope === 'public'
      },
      {
        id: 'user_account_needed',
        question: '用户需要注册账号吗？',
        type: 'single_choice',
        options: [
          { id: 'no_account', text: '不需要，直接使用' },
          { id: 'optional', text: '可选，注册后有更多功能' },
          { id: 'required', text: '必须注册才能使用' },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.coreFeatures?.some(f => f.includes('注册') || f.includes('登录'))
      },
      {
        id: 'content_management',
        question: '用户会在产品中创建或管理内容吗？',
        type: 'single_choice',
        options: [
          { id: 'no_content', text: '不需要，只是使用功能' },
          { id: 'simple_content', text: '简单的内容创建' },
          { id: 'rich_content', text: '复杂的内容管理' },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.coreFeatures?.some(f => {
          f.includes('创建') || f.includes('编辑') || f.includes('管理')
        })
      },
      {
        id: 'success_measure',
        question: '如果这个产品做好了，最让您满意的是什么？',
        type: 'text_simple',
        placeholder: '例如：用户觉得很有用、解决了实际问题、操作很方便...',
        relevanceCheck: () => true // 总是询问成功标准
      }
    ]
  }
}
```

class AdaptiveQuestionGenerator {
  generateQuestions(
    extractedInfo: ExtractedInfo,
    userInputResult: UserInputResult
  ): Question[] {
    // 1. 确定产品类型和用户范围
    const userScope = this.determineUserScope(extractedInfo, userInputResult)
    const questionSet = ADAPTIVE_QUESTION_SETS[userScope] || ADAPTIVE_QUESTION_SETS.personal_tool
    // 2. 过滤相关问题
    let relevantQuestions = questionSet.questions.filter(q => {
      q.relevanceCheck(extractedInfo)
    })
    // 3. 生成场景化问题（如果基础信息不足）
    const scenarioQuestions = this.generateScenarioQuestions(extractedInfo)
    relevantQuestions = [...relevantQuestions, ...scenarioQuestions]
    // 4. 按重要性排序并限制数量
    return relevantQuestions
      .sort((a, b) => (b.priority || 0) - (a.priority || 0))
      .slice(0, questionSet.maxQuestions)
  }

  private determineUserScope(
    extractedInfo: ExtractedInfo,
    userInputResult: UserInputResult
  ): string {
    // 1. 如果已经提取到用户范围，直接使用
    if (extractedInfo.userScope) {
      return `${extractedInfo.userScope}_tool`
    }
    // 2. 基于关键词分析
    const text = userInputResult.originalInput.text.toLowerCase()
    const personalKeywords = ['个人', '自己', '我的', '自用']
    const teamKeywords = ['团队', '公司', '同事', '协作', '小组']
    const publicKeywords = ['用户', '大家', '公开', '分享', '平台']
    if (personalKeywords.some(keyword => text.includes(keyword))) {
      return 'personal_tool'
    } else if (teamKeywords.some(keyword => text.includes(keyword))) {
      return 'small_team_tool'
    } else if (publicKeywords.some(keyword => text.includes(keyword))) {
      return 'public_product'
    }
    // 3. 基于产品类型推断
    const productType = extractedInfo.productType?.toLowerCase() || ''
    if (productType.includes('插件') || productType.includes('工具')) {
      return 'personal_tool'
    } else if (productType.includes('管理') || productType.includes('协作')) {
      return 'small_team_tool'
    }
    // 4. 默认为个人工具
    return 'personal_tool'
  }

  private generateScenarioQuestions(extractedInfo: ExtractedInfo): Question[] {
    const scenarioQuestions: Question[] = []
    // 如果缺少核心工作流程
    if (!extractedInfo.useScenario) {
      scenarioQuestions.push({
        id: 'simple_workflow',
        question: `假设您现在就要使用这个${extractedInfo.productType || '工具'}，您会怎么操作？`,
        type: 'text_simple',
        placeholder: '例如：打开工具 → 输入内容 → 点击处理 → 查看结果',
        priority: 10
      })
    }
    // 如果缺少痛点信息
    if (!extractedInfo.painPoint && !extractedInfo.currentSolution) {
      scenarioQuestions.push({
        id: 'current_solution',
        question: '您现在是怎么解决这个问题的？有什么不方便的地方？',
        type: 'text_simple',
        placeholder: '例如：现在要手动计算，很麻烦...',
        priority: 8
      })
    }
    return scenarioQuestions
  }
}
```

### 3. 问答交互界面

```typescript
const SmartQuestioningInterface = ( {
  questions,
  onAnswersComplete
}: {
  questions: Question[],
  onAnswersComplete: (answers: Answer[]) => void
}) => {
  const [currentIndex, setCurrentIndex] = useState(0)
  const [answers, setAnswers] = useState<Answer[]>([])
  const [isAnimating, setIsAnimating] = useState(false)
  const handleAnswer = async (answer: AnswerValue) => {
    const newAnswer: Answer = {
      questionId: questions[currentIndex].id,
      value: answer,
      timestamp: new Date()
    }
    const newAnswers = [...answers, newAnswer]
    setAnswers(newAnswers)
    // 动画效果
    setIsAnimating(true)
    await new Promise(resolve => setTimeout(resolve, 300))
    if (currentIndex < questions.length - 1) {
      setCurrentIndex(currentIndex + 1)
    } else {
      onAnswersComplete(newAnswers)
    }
    setIsAnimating(false)
  }

  const currentQuestion = questions[currentIndex]
  return (
    <div className="smart-questioning-interface">
      <div className="progress-bar">
        <div>
          <div className="progress-fill" style={{ width: `${((currentIndex + 1) / questions.length) * 100}%` }}></div>
          <span className="progress-text">{currentIndex + 1} / {questions.length}</span>
        </div>
      </div>
      <div className={`question-container ${isAnimating ? 'animating' : ''}`}>
        <div className="question-card">
          <h3 className="question-title">{currentQuestion.question}</h3>
          {currentQuestion.type === 'single_choice' && (
            <div className="choice-options">
              {currentQuestion.options?.map((option, index) => (
                <button
                  key={option.id}
                  className="choice-button"
                  onClick={() => handleAnswer(option.id)}
                >
                  {option.text}
                </button>
              ))}
            </div>
          )}
          {currentQuestion.type === 'text_simple' && (
            <div className="text-input-section">
              <textarea
                placeholder={currentQuestion.placeholder}
                className="simple-text-input"
                onKeyPress={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault()
                    const value = (e.target as HTMLTextAreaElement).value.trim()
                    if (value) {
                      handleAnswer(value)
                    }
                  }
                }
              />
              <div className="text-input-actions">
                <button
                  onClick={() => {
                    const textarea = document.querySelector('.simple-text-input') as HTMLTextAreaElement
                    const value = textarea.value.trim()
                    if (value) {
                      handleAnswer(value)
                    }
                  }}
                  className="submit-text-button"
                >
                  确认
                </button>
              </div>
            </div>
          )}
        </div>
        {/* 已回答问题的预览 */
        <div className="answered-questions">
          {answers.map((answer, index) => (
            <div key={index} className="answered-item">
              <span className="answered-question">
                {questions.find(q => q.id === answer.questionId)?.question}
              </span>
              <span className="answered-value">
                {formatAnswerValue(answer.value)}
              </span>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

### 4. 动态问题生成控制器

```typescript
class DynamicQuestioningController {
  async processUserAnswers(
    answers: Answer[],
    sessionState: SessionState
  ): Promise<QuestioningDecision> {
    // 1. 更新信息状态
    const updatedInfo = await this.updateExtractedInfo(sessionState.extractedInfo, answers)

    // 2. 重新评估完整性
    const newCompleteness = this.evaluateInformationCompleteness({
      ...sessionState,
      extractedInfo: updatedInfo
    })

    // 3. 智能决策：继续问答 vs 进入确认
    if (this.shouldContinueQuestioning(updatedInfo, sessionState.questionCount, newCompleteness)) {
      // 生成下一轮问题
      const nextQuestions = await this.generateNextQuestions(updatedInfo, sessionState.questionCount + 1)
      return {
        action: 'continue_questioning',
        questions: nextQuestions,
        extractedInfo: updatedInfo,
        completeness: newCompleteness,
        reason: this.explainContinueReason(newCompleteness)
      }
    } else {
      // 进入需求确认
      return {
        action: 'proceed_to_confirmation',
        extractedInfo: updatedInfo,
        completeness: newCompleteness,
        confidence: newCompleteness.overall
      }
    }
  }

  private async generateNextQuestions(
    extractedInfo: ExtractedInfo,
    questionCount: number
  ): Promise<Question[]> {
    // 基于信息完整性生成问题
    const missingCritical = this.identifyMissingCriticalInfo(extractedInfo)
    const missingImportant = this.identifyMissingImportantInfo(extractedInfo)

    const questions: Question[] = []

    // 优先处理关键信息缺失
    if (missingCritical.length > 0) {
      questions.push(...await this.generateCriticalQuestions(missingCritical, extractedInfo))
    }

    // 然后处理重要信息缺失
    if (questions.length < 2 && missingImportant.length > 0) {
      questions.push(...await this.generateImportantQuestions(missingImportant, extractedInfo))
    }

    // 限制问题数量（避免用户疲劳）
    const maxQuestions = Math.max(1, 4 - Math.floor(questionCount / 2))
    return questions.slice(0, maxQuestions)
  }

  private explainContinueReason(completeness: InformationCompleteness): string {
    if (completeness.critical < 0.85) {
      return '核心信息不足，需要继续收集'
    }
    if (completeness.important < 0.75) {
      return '重要信息不完整，建议补充'
    }
    if (completeness.overall < 0.8) {
      return '整体信息还需要完善'
    }
    return '信息收集完成'
  }
}
```

### 5. 智能完整性评估器

```typescript
interface InformationCompleteness {
  critical: number;    // 关键信息完整度 (0-1)
  important: number;   // 重要信息完整度 (0-1)
  optional: number;    // 可选信息完整度 (0-1)
  overall: number;     // 整体完整度 (0-1)
}

class IntelligentCompletenessChecker {
  evaluateInformationCompleteness(extractedInfo: ExtractedInfo): InformationCompleteness {
    const critical = this.evaluateCriticalInfoCompleteness(extractedInfo);
    const important = this.evaluateImportantInfoCompleteness(extractedInfo);
    const optional = this.evaluateOptionalInfoCompleteness(extractedInfo);

    // 加权计算整体完整度
    const overall = critical * 0.6 + important * 0.3 + optional * 0.1;

    return {
      critical,
      important,
      optional,
      overall
    };
  }

  shouldProceedToConfirmation(completeness: InformationCompleteness, questionCount: number): boolean {
    // 关键信息必须充足
    if (completeness.critical < 0.85) return false;

    // 重要信息基本充足 + 不要过度询问
    if (completeness.important >= 0.75 || questionCount >= 6) return true;

    // 整体信息充足
    if (completeness.overall >= 0.8) return true;

    return false;
  }

  private evaluateOptionalInfoCompleteness(extractedInfo: ExtractedInfo): number {
    const optionalFields = [
      'performanceRequirements',  // 性能要求
      'integrationNeeds',        // 集成需求
      'constraints',             // 约束条件
      'successCriteria'          // 成功标准
    ];

    let completedCount = 0;
    let totalWeight = 0;

    for (const field of optionalFields) {
      totalWeight += 1;
      if (this.isFieldComplete(extractedInfo[field])) {
        completedCount += 1;
      }
    }

    return totalWeight > 0 ? completedCount / totalWeight : 1;
  }
          <div className="complexity-section">
            <h3>技术复杂度</h3>
            <span className={`complexity-badge ${summary.technicalLevel}`}>
              {getComplexityLabel(summary.technicalLevel)}
            </span>
          </div>
        </div>
        <div className="features-section">
          <h3>主要功能</h3>
          {summary.mainFeatures.map((feature, index) => (
            <div key={index} className="feature-item">
              <div className="feature-content">
                <span className="feature-name">{feature.name}</span>
                <span className="feature-desc">{feature.description}</span>
                {feature.essential && <span className="essential-badge">核心</span>}
              </div>
              <div className="feature-actions">
                <button onClick={() => toggleAdjustment('modify_feature', feature, index)}>
                  修改
                </button>
                <button onClick={() => toggleAdjustment('remove_feature', feature, index)}>
                  删除
                </button>
              </div>
            </div>
          ))}
          <button
            className="add-feature-button"
            onClick={() => toggleAdjustment('add_feature')}
          >
            + 添加功能
          </button>
        </div>
      </div>
      {/* 调整面板 */
      {selectedAdjustments.length > 0 && (
        <div className="adjustment-panel">
          <h4>需要调整的内容</h4>
          {selectedAdjustments.map((adj, index) => (
            <AdjustmentItem
              key={index}
              adjustment={adj}
              onUpdate={(updated) => updateAdjustment(index, updated)}
              onRemove={() => removeAdjustment(index)}
            />
          ))}
          <div className="adjustment-actions">
            <button onClick={() => onAdjust(selectedAdjustments)}>
              应用调整
            </button>
            <button onClick={() => setSelectedAdjustments([])}>
              取消
            </button>
          </div>
        </div>
      )}
      <div className="confirmation-actions">
        <button onClick={onConfirm} className="primary-confirm-btn">
          ✅ 理解准确，生成PRD
        </button>
        <button onClick={() => setShowAdjustmentHelp(true)} className="secondary-adjust-btn">
          🔧 需要微调
        </button>
        <button onClick={onRestart} className="restart-btn">
          🔄 重新开始问答
        </button>
      </div>
    </div>
  )
}
```

## 完整流程示例

### 示例：浏览器插件项目

#### Step 1: 接收用户输入结果

```typescript
const userInputResult: UserInputResult = {
  originalInput: {
    text: "我想做一个浏览器插件，可以自动提取网页中的邮箱地址，我经常需要收集客户邮箱，现在要手动复制粘贴很麻烦",
    images: [],
    timestamp: new Date()
  },
  multimodalAnalysis: {
    textSummary: "用户想开发浏览器插件来自动提取网页邮箱地址",
    imageDescriptions: [],
    extractedText: [],
    combinedContext: "我想做一个浏览器插件，可以自动提取网页中的邮箱地址，我经常需要收集客户邮箱，现在要手动复制粘贴很麻烦",
    confidence: 0.95
  },
  validation: {
    isValid: true,
    hasContent: true,
    wordCount: 45,
    issues: []
  }
};
```

#### Step 2: 智能信息提取

```typescript
const extractedInfo: ExtractedInfo = {
  productType: "浏览器插件",
  coreGoal: "自动提取网页中的邮箱地址，提高收集效率",
  targetUsers: "经常需要收集客户邮箱的个人用户",
  userScope: "personal",
  coreFeatures: ["自动识别网页邮箱", "一键提取功能"],
  useScenario: "收集客户邮箱时使用",
  userJourney: "打开网页 → 点击插件 → 自动提取邮箱 → 复制或保存",
  inputOutput: "输入：当前网页内容，输出：提取的邮箱地址列表",
  painPoint: "手动复制粘贴很麻烦",
  currentSolution: "手动查找和复制粘贴邮箱地址",
  technicalHints: ["浏览器插件", "网页内容解析"],
  integrationNeeds: [],
  performanceRequirements: "快速识别，准确提取"
};
```

#### Step 3: 评估信息完整性，生成针对性问题

```typescript
// 完整性评估
const completeness: InformationCompleteness = {
  critical: 0.9,    // 关键信息充足：产品类型、目标、用户、核心功能
  important: 0.7,   // 重要信息缺失：使用频率、数据保存方式
  optional: 0.4,    // 可选信息缺失：性能要求、集成需求
  overall: 0.78     // 整体完整度
};

// 生成问题（因为important < 0.75，需要补充）
const questions: Question[] = [
  {
    id: 'usage_frequency_001',
    question: "您大概多久会使用一次这个插件？",
    type: 'single_choice',
    options: [
      { id: 'daily', text: '每天都用' },
      { id: 'weekly', text: '每周几次' },
      { id: 'occasional', text: '偶尔使用' }
    ],
    targetSlots: ['usage_frequency'],
    priority: 8
  },
  {
    id: 'data_handling_001',
    question: "提取的邮箱地址需要保存吗？",
    type: 'single_choice',
    options: [
      { id: 'no_save', text: '不需要，直接复制使用' },
      { id: 'local_file', text: '保存到本地文件' },
      { id: 'history', text: '保存提取历史记录' }
    ],
    targetSlots: ['data_persistence'],
    priority: 7
  }
];
```

#### Step 4: 处理用户答案，完成信息收集

```typescript
const answers: Answer[] = [
  {
    questionId: 'usage_frequency_001',
    value: 'weekly',
    timestamp: new Date()
  },
  {
    questionId: 'data_handling_001',
    value: 'local_file',
    timestamp: new Date()
  }
];

// 更新提取信息
const finalExtractedInfo: ExtractedInfo = {
  ...extractedInfo,
  // 基于答案更新信息
  useScenario: "每周几次收集客户邮箱时使用",
  coreFeatures: [
    "自动识别网页邮箱",
    "一键提取功能",
    "保存到本地文件"
  ],
  dataHandling: "保存提取结果到本地Excel或CSV文件"
};

// 重新评估完整性
const finalCompleteness: InformationCompleteness = {
  critical: 0.9,
  important: 0.85,  // 重要信息现在充足了
  optional: 0.5,
  overall: 0.83     // 整体完整度达标
};
```

#### Step 5: 生成最终输出

```typescript
const questioningResult: SmartQuestioningResult = {
  extractedInfo: finalExtractedInfo,
  questioningSession: {
    questions,
    answers,
    totalRounds: 1,
    duration: 120, // 120秒
    completionReason: "信息完整度达标(83%)"
  },
  completeness: finalCompleteness,
  userInputResult,
  validation: {
    extractionConfidence: 0.9,
    questioningQuality: 0.85,
    readyForConfirmation: true
  }
};
```

## 输出接口

```typescript
interface SmartQuestioningResult {
  // 核心提取信息
  extractedInfo: ExtractedInfo;

  // 问答会话数据
  questioningSession: {
    questions: Question[];
    answers: Answer[];
    totalRounds: number;
    duration: number;
    completionReason: string;
  };

  // 信息完整性评估
  completeness: {
    critical: number;      // 关键信息完整度 (0-1)
    important: number;     // 重要信息完整度 (0-1)
    optional: number;      // 可选信息完整度 (0-1)
    overall: number;       // 整体完整度 (0-1)
  };

  // 用户输入原始数据
  userInputResult: UserInputResult;

  // 质量验证
  validation: {
    extractionConfidence: number;  // 信息提取置信度
    questioningQuality: number;    // 问答质量评分
    readyForConfirmation: boolean; // 是否准备好进入确认阶段
  };
}

interface ExtractedInfo {
  // 产品基础信息
  productType: string;           // 产品类型
  coreGoal: string;             // 核心目标
  targetUsers: string;          // 目标用户
  userScope: 'personal' | 'small_team' | 'public';

  // 功能相关信息
  coreFeatures: string[];       // 核心功能列表
  useScenario: string;          // 使用场景
  userJourney: string;          // 用户流程
  inputOutput: string;          // 输入输出描述

  // 上下文信息
  painPoint: string;            // 用户痛点
  currentSolution: string;      // 现有解决方案

  // 技术相关
  technicalHints: string[];     // 技术线索
  integrationNeeds: string[];   // 集成需求
  performanceRequirements: string; // 性能要求
  dataHandling?: string;        // 数据处理方式（可选）
}

interface Question {
  id: string;
  question: string;
  type: 'single_choice' | 'text_simple';
  options?: { id: string; text: string }[];
  placeholder?: string;
  targetSlots: string[];
  priority: number;
}

interface Answer {
  questionId: string;
  value: string;
  timestamp: Date;
}
```

## 关键特性

### ✅ **AI智能分析对话历史**
- 避免重复询问显而易见的信息
- 从用户描述中智能推断产品类型、用户群体等基础信息
- 基于信息完整性动态调整问题策略

### ✅ **基于PRD需求精准收集信息**
- 问题直接对应PRD生成所需的核心信息
- 避免商业背景、竞品分析等传统PRD内容
- 强化功能实现相关信息收集

### ✅ **基于信息完整性的智能问答策略**
- 实时评估关键信息、重要信息、可选信息的完整度
- 智能决定是否继续提问，而非预设问题数量
- 防止过度询问的安全机制（最多8轮对话）
- 85%关键信息完整度门槛，确保PRD生成质量

### ✅ **面向AI Coding场景优化**
- 弱化传统PRD的商业论证部分
- 强化技术实现和功能细节收集
- 适合"用Cursor制作提效工具"的使用场景

## 与后续模块的接口

### 输入：来自用户输入模块
- `UserInputResult`：用户的原始需求描述（文本+图片）

### 输出：传递给需求确认模块
智能问答模块完成后，输出 `SmartQuestioningResult` 给**需求确认模块（03模块）**，包含：

1. **提取的需求信息**：经过AI分析和问答补充的结构化需求信息
2. **问答会话记录**：完整的问题和答案历史，供后续参考
3. **信息完整性评估**：各维度信息的完整度评分，帮助判断质量
4. **原始输入数据**：保留用户最初的需求描述，供需求确认时参考

**注意**：本模块**不负责**需求确认和总结生成，这些工作由03模块完成。
