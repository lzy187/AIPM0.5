# æ™ºèƒ½é—®ç­”æ¨¡å—è®¾è®¡ï¼ˆä¼˜åŒ–ç‰ˆï¼‰

## æ¨¡å—æ¦‚è¿°
æ™ºèƒ½é—®ç­”æ¨¡å—é€šè¿‡AIåˆ†æå¯¹è¯å†å²ï¼ŒåŸºäºPRDç”Ÿæˆéœ€æ±‚ç²¾å‡†æ”¶é›†å…³é”®ä¿¡æ¯ï¼Œé‡‡ç”¨åŠ¨æ€æ°”æ³¡äº¤äº’ï¼Œä¸ºAI Codingåœºæ™¯é‡èº«å®šåˆ¶ï¼Œå¼±åŒ–å•†ä¸šè®ºè¯ï¼Œå¼ºåŒ–åŠŸèƒ½å®ç°ã€‚

## æ ¸å¿ƒè®¾è®¡åŸåˆ™

### âœ… **AIæ™ºèƒ½åˆ†æå¯¹è¯å†å²**
- é¿å…é‡å¤è¯¢é—®æ˜¾è€Œæ˜“è§çš„ä¿¡æ¯

### âœ… **åŸºäºPRDéœ€æ±‚ç²¾å‡†æ”¶é›†ä¿¡æ¯**
- é—®é¢˜ç›´æ¥å¯¹åº”PRDç”Ÿæˆæ‰€éœ€çš„æ ¸å¿ƒä¿¡æ¯
- é¿å…å•†ä¸šèƒŒæ™¯ã€ç«å“åˆ†æç­‰ä¼ ç»ŸPRDå†…å®¹
- å¼ºåŒ–åŠŸèƒ½å®ç°ç›¸å…³ä¿¡æ¯æ”¶é›†

### âœ… **åŸºäºä¿¡æ¯å®Œæ•´æ€§çš„æ™ºèƒ½é—®ç­”ç­–ç•¥**
- åŠ¨æ€è¯„ä¼°éœ€æ±‚ä¿¡æ¯çš„å®Œæ•´æ€§ï¼Œæ™ºèƒ½å†³å®šæ˜¯å¦ç»§ç»­æé—®
- æ ¹æ®å…³é”®ä¿¡æ¯ã€é‡è¦ä¿¡æ¯ã€å¯é€‰ä¿¡æ¯çš„ç¼ºå¤±ç¨‹åº¦è°ƒæ•´é—®é¢˜ç­–ç•¥
- é¿å…ç¡¬ç¼–ç é—®é¢˜æ•°é‡ï¼ŒåŸºäºå®é™…éœ€è¦ç”Ÿæˆé—®é¢˜

### âœ… **é¢å‘AI Codingåœºæ™¯ä¼˜åŒ–**
- å¼±åŒ–ä¼ ç»ŸPRDçš„å•†ä¸šè®ºè¯éƒ¨åˆ†
- å¼ºåŒ–æŠ€æœ¯å®ç°å’ŒåŠŸèƒ½ç»†èŠ‚æ”¶é›†
- é€‚åˆ"ç”¨Cursoråˆ¶ä½œææ•ˆå·¥å…·"çš„ä½¿ç”¨åœºæ™¯

## ğŸ“‹ ä¿¡æ¯æ”¶é›†ç­–ç•¥è®¾è®¡

### 1. åŸºäºPRDéœ€æ±‚çš„ä¿¡æ¯æ˜ å°„

```typescript
// æ ¹æ®ä¼˜åŒ–çš„PRDç»“æ„ï¼Œåæ¨å¿…éœ€ä¿¡æ¯
interface PRDRequiredInfo {
  // äº§å“å®šä¹‰ï¼ˆç”ŸæˆproductOverviewï¼‰
  productDefinition: {
    type: string;           // äº§å“ç±»å‹ - ä»ç”¨æˆ·æè¿°æ¨æ–­
    coreGoal: string;       // æ ¸å¿ƒç›®æ ‡ - ç”¨æˆ·åŸè¯
    targetUsers: string;    // ç›®æ ‡ç”¨æˆ· - ç®€å•æè¿°
    useScenarios: string[]; // ä½¿ç”¨åœºæ™¯ - ä½•æ—¶ä½•æ—¶ä½¿ç”¨
  };

  // åŠŸèƒ½éœ€æ±‚ï¼ˆç”ŸæˆfunctionalRequirementsï¼‰
  functionalRequirements: {
    coreFeatures: string[];     // æ ¸å¿ƒåŠŸèƒ½æ¸…å•
    userJourney: string;        // ç”¨æˆ·æ“ä½œæµç¨‹
    inputOutput: string;        // è¾“å…¥è¾“å‡ºæè¿°
    dataHandling?: string;      // æ•°æ®å¤„ç†æ–¹å¼ï¼ˆå¦‚éœ€è¦ï¼‰
    integrationNeeds?: string[]; // é›†æˆéœ€æ±‚ï¼ˆå¦‚éœ€è¦ï¼‰
  };

  // æŠ€æœ¯çº¦æŸï¼ˆç”ŸæˆtechnicalSpecsï¼‰
  technicalConstraints: {
    complexity: 'simple' | 'moderate' | 'complex'; // å¤æ‚åº¦
    platformHints?: string;     // å¹³å°çº¿ç´¢
    performanceNeeds?: string;  // æ€§èƒ½è¦æ±‚
  };

  // ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆä¼˜åŒ–PRDè´¨é‡ï¼‰
  contextInfo: {
    painPoints: string[];       // ç”¨æˆ·ç—›ç‚¹
    currentSolution?: string;   // ç°æœ‰è§£å†³æ–¹æ¡ˆ
    successCriteria?: string;   // æˆåŠŸæ ‡å‡†
  };
}
```

### 2. æ™ºèƒ½ä¿¡æ¯æå–å¼•æ“

```typescript
class SmartInfoExtractor {
  async analyzeConversation(messages: ConversationMessage[]): Promise<ExtractionResult> {
    const prompt = `
ä½ æ˜¯AIäº§å“ç»ç†åŠ©æ‰‹ï¼Œåˆ†æå¯¹è¯æå–PRDç”Ÿæˆæ‰€éœ€ä¿¡æ¯ã€‚

å¯¹è¯å†å²ï¼š
${messages.map(m => `${m.role}: ${m.content}`).join('
')}

ä»»åŠ¡ï¼š
1. æå–å·²æ˜ç¡®çš„ä¿¡æ¯ï¼Œæ ‡è®°ç½®ä¿¡åº¦
2. è¯†åˆ«ç”ŸæˆPRDè¿˜ç¼ºå°‘çš„å…³é”®ä¿¡æ¯
3. ç”Ÿæˆ1-3ä¸ªç²¾å‡†é—®é¢˜æ”¶é›†ç¼ºå¤±ä¿¡æ¯
4. é¿å…å•†ä¸šèƒŒæ™¯ã€ç«å“åˆ†æç­‰é—®é¢˜

PRDç”Ÿæˆæ ¸å¿ƒä¿¡æ¯éœ€æ±‚ï¼š
ã€äº§å“å®šä¹‰ã€‘
- äº§å“ç±»å‹ï¼ˆä»æè¿°æ¨æ–­ï¼Œå¦‚ï¼šæµè§ˆå™¨æ’ä»¶ã€Webå·¥å…·ã€ç®¡ç†ç³»ç»Ÿï¼‰
- æ ¸å¿ƒç›®æ ‡ï¼ˆç”¨æˆ·æƒ³è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Œç”¨ç”¨æˆ·çš„è¯­è¨€ï¼‰
- ç›®æ ‡ç”¨æˆ·ï¼ˆè°ä½¿ç”¨ï¼šä¸ªäºº/å°å›¢é˜Ÿ/å…¬ä¼—ï¼‰
- ä½¿ç”¨åœºæ™¯ï¼ˆä»€ä¹ˆæ—¶å€™ã€ä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨ï¼‰

ã€åŠŸèƒ½éœ€æ±‚ã€‘
- æ ¸å¿ƒåŠŸèƒ½æ¸…å•ï¼ˆ3-5ä¸ªä¸»è¦åŠŸèƒ½ï¼‰
- ç”¨æˆ·æ“ä½œæµç¨‹ï¼ˆä»å¼€å§‹åˆ°ç»“æŸçš„æ­¥éª¤ï¼‰
- è¾“å…¥è¾“å‡ºï¼ˆç”¨æˆ·è¾“å…¥ä»€ä¹ˆï¼Œå¾—åˆ°ä»€ä¹ˆç»“æœï¼‰
- æ•°æ®å¤„ç†ï¼ˆå¦‚ä½•å¤„ç†æ•°æ®ï¼Œæ˜¯å¦éœ€è¦ä¿å­˜ï¼‰

ã€å®ç°çº¦æŸã€‘
- æŠ€æœ¯å¤æ‚åº¦ï¼ˆä»åŠŸèƒ½æ¨æ–­ï¼šç®€å•/ä¸­ç­‰/å¤æ‚ï¼‰
- æ€§èƒ½è¦æ±‚ï¼ˆå¦‚æœ‰æ˜ç¡®éœ€æ±‚ï¼‰

ç»å¯¹ä¸è¦è¯¢é—®çš„å†…å®¹ï¼š
âŒ ä¸šåŠ¡èƒŒæ™¯ã€å•†ä¸šæ¨¡å¼
âŒ ç«å“åˆ†æã€å¸‚åœºè°ƒç ”
âŒ è¿è¥ç­–ç•¥ã€æ¨å¹¿æ–¹æ¡ˆ
âŒ ROIã€å•†ä¸šä»·å€¼è®ºè¯
âŒ é¡¹ç›®ç®¡ç†ã€å›¢é˜Ÿç»„ç»‡
âŒ å…·ä½“æŠ€æœ¯æ ˆé€‰æ‹©ï¼ˆè¿™æ˜¯AI Codingé˜¶æ®µçš„äº‹ï¼‰

å“åº”æ ¼å¼ï¼ˆJSONï¼‰ï¼š
`

    return await this.aiClient.chatCompletion([
      { role: 'system', content: prompt },
      { role: 'user', content: 'è¯·åˆ†æå¯¹è¯å¹¶ç”Ÿæˆä¿¡æ¯æå–ç»“æœ' },
    ])
  }
}
```

### 3. äº§å“ç±»å‹è‡ªé€‚åº”é—®é¢˜åº“

```typescript
// åŸºäºäº§å“ç±»å‹çš„ç²¾å‡†é—®é¢˜ç­–ç•¥
const SMART_QUESTIONS_BY_TYPE = {
  'browser_extension': {
    criticalInfo: ['triggerMechanism', 'dataHandling', 'permissions'],
    smartQuestions: [
      {
        condition: 'missing_trigger_mechanism',
        question: 'æ’ä»¶ä»€ä¹ˆæ—¶å€™å¼€å§‹å·¥ä½œï¼Ÿ',
        type: 'choice',
        options: [
          'æ‰“å¼€ç‰¹å®šç½‘é¡µæ—¶è‡ªåŠ¨è¿è¡Œ',
          'ç”¨æˆ·ç‚¹å‡»æ’ä»¶å›¾æ ‡æ—¶è¿è¡Œ',
          'ç”¨æˆ·é€‰ä¸­å†…å®¹åå³é”®è¿è¡Œ',
          'åœ¨åå°æŒç»­ç›‘æ§',
        ],
        purpose: 'determine_user_flow',
      },
      {
        condition: 'missing_data_handling',
        question: 'å¤„ç†çš„æ•°æ®éœ€è¦ä¿å­˜å—ï¼Ÿ',
        type: 'choice',
        options: [
          'ä¸ä¿å­˜ï¼Œç›´æ¥ä½¿ç”¨',
          'ä¿å­˜åˆ°æœ¬åœ°ä¾›ä¸‹è½½',
          'ä¿å­˜è®¾ç½®å’Œå†å²è®°å½•',
          'åŒæ­¥åˆ°äº‘ç«¯',
        ],
        purpose: 'determine_data_requirements',
      },
    ]
  },
  'utility_tool': {
    criticalInfo: ['inputOutput', 'processFlow', 'usageFrequency'],
    smartQuestions: [
      {
        condition: 'missing_input_output',
        question: 'ç”¨æˆ·éœ€è¦è¾“å…¥ä»€ä¹ˆï¼Œä¼šå¾—åˆ°ä»€ä¹ˆï¼Ÿ',
        type: 'text',
        placeholder: 'ä¾‹å¦‚ï¼šè¾“å…¥ä¸€æ®µæ–‡æœ¬ï¼Œè¾“å‡ºç»Ÿè®¡åˆ†æç»“æœ',
        purpose: 'define_core_functionality',
      },
      {
        condition: 'missing_process_flow',
        question: 'ç”¨æˆ·ä½¿ç”¨è¿™ä¸ªå·¥å…·çš„å®Œæ•´æµç¨‹æ˜¯ï¼Ÿ',
        type: 'text',
        placeholder: 'ä¾‹å¦‚ï¼šä¸Šä¼ æ–‡ä»¶ â†’ é€‰æ‹©å¤„ç†æ–¹å¼ â†’ ç‚¹å‡»å¼€å§‹ â†’ ä¸‹è½½ç»“æœ',
        purpose: 'define_user_journey',
      },
    ]
  },
  'management_tool': {
    criticalInfo: ['userRoles', 'dataStructure', 'workflow', 'collaboration'],
    smartQuestions: [
      {
        condition: 'missing_user_roles',
        question: 'ä¼šæœ‰å¤šå°‘äººä½¿ç”¨è¿™ä¸ªå·¥å…·ï¼Ÿ',
        type: 'choice',
        options: [
          'åªæœ‰æˆ‘è‡ªå·±',
          'æˆ‘å’Œ2-5ä¸ªåŒäº‹',
          'æ•´ä¸ªå›¢é˜Ÿ(6-20äºº)',
          'æ›´å¤§è§„æ¨¡çš„ç»„ç»‡',
        ],
        purpose: 'determine_collaboration_needs',
      },
      {
        condition: 'missing_workflow',
        question: 'å…¸å‹çš„ç®¡ç†æµç¨‹æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ',
        type: 'text',
        placeholder: 'ä¾‹å¦‚ï¼šåˆ›å»ºä»»åŠ¡ â†’ åˆ†é…è´£ä»»äºº â†’ è·Ÿè¸ªè¿›åº¦ â†’ æ ‡è®°å®Œæˆ',
        purpose: 'define_management_workflow',
      },
    ]
  },
  'web_app': {
    criticalInfo: ['userScope', 'coreFeatures', 'dataModel'],
    smartQuestions: [
      {
        condition: 'missing_user_scope',
        question: 'è¿™ä¸ªåº”ç”¨ä¸»è¦ç»™è°ä½¿ç”¨ï¼Ÿ',
        type: 'choice',
        options: [
          'æˆ‘ä¸ªäººä½¿ç”¨',
          'æˆ‘å’Œå›¢é˜Ÿä½¿ç”¨',
          'å¯¹å¤–æä¾›ç»™ç”¨æˆ·ä½¿ç”¨',
          'ä¸ç¡®å®šï¼Œçœ‹æƒ…å†µ',
        ],
        purpose: 'determine_user_scope_and_features',
      },
    ]
  }
}
```

### 4. æ™ºèƒ½é—®é¢˜é€‰æ‹©ç®—æ³•

```typescript
class SmartQuestionSelector {
  selectOptimalQuestions(
    extractedInfo: ExtractedInfo,
    productType: string,
    conversationLength: number
  ): Question[] {
    const productConfig = SMART_QUESTIONS_BY_TYPE[productType] || SMART_QUESTIONS_BY_TYPE['utility_tool']
    // 1. åŸºäºç¼ºå¤±çš„å…³é”®ä¿¡æ¯é€‰æ‹©é—®é¢˜
    const missingInfo = this.identifyMissingCriticalInfo(extractedInfo, productConfig.criticalInfo)
    // 2. æ ¹æ®å¯¹è¯é•¿åº¦è°ƒæ•´é—®é¢˜æ•°é‡
    const maxQuestions = this.getMaxQuestions(conversationLength, productType)
    // 3. æŒ‰ä¼˜å…ˆçº§é€‰æ‹©é—®é¢˜
    const selectedQuestions = missingInfo
      .slice(0, maxQuestions)
      .map(infoType => this.findQuestionByType(productConfig, infoType))
      .filter(Boolean)
    return selectedQuestions
  }

  private shouldContinueQuestioning(
    extractedInfo: ExtractedInfo,
    conversationLength: number,
    currentCompleteness: InformationCompleteness
  ): boolean {
    // 1. é˜²æ­¢è¿‡åº¦è¯¢é—®çš„å®‰å…¨é™åˆ¶
    if (conversationLength >= 8) return false; // æœ€å¤š8è½®å¯¹è¯

    // 2. åŸºäºä¿¡æ¯å®Œæ•´æ€§æ™ºèƒ½åˆ¤æ–­
    const criticalComplete = this.evaluateCriticalInfoCompleteness(extractedInfo);
    const importantComplete = this.evaluateImportantInfoCompleteness(extractedInfo);

    // 3. å…³é”®ä¿¡æ¯ä¸è¶³ï¼Œå¿…é¡»ç»§ç»­
    if (criticalComplete < 0.85) return true;

    // 4. é‡è¦ä¿¡æ¯ä¸è¶³ä¸”å¯¹è¯è¾ƒå°‘ï¼Œå¯ä»¥ç»§ç»­
    if (importantComplete < 0.75 && conversationLength < 5) return true;

    // 5. æ•´ä½“å®Œæ•´æ€§ä¸è¶³ä¸”åˆšå¼€å§‹ï¼Œå¯ä»¥ç»§ç»­
    if (currentCompleteness.overall < 0.8 && conversationLength < 3) return true;

    // 6. å…¶ä»–æƒ…å†µåœæ­¢é—®ç­”
    return false;
  }

  private evaluateCriticalInfoCompleteness(extractedInfo: ExtractedInfo): number {
    const criticalFields = [
      'productType',    // äº§å“ç±»å‹
      'coreGoal',       // æ ¸å¿ƒç›®æ ‡
      'targetUsers',    // ç›®æ ‡ç”¨æˆ·
      'coreFeatures'    // æ ¸å¿ƒåŠŸèƒ½
    ];

    let completedCount = 0;
    let totalWeight = 0;

    for (const field of criticalFields) {
      totalWeight += 1;
      if (this.isFieldComplete(extractedInfo[field])) {
        completedCount += 1;
      }
    }

    return completedCount / totalWeight;
  }

  private evaluateImportantInfoCompleteness(extractedInfo: ExtractedInfo): number {
    const importantFields = [
      'useScenario',     // ä½¿ç”¨åœºæ™¯
      'inputOutput',     // è¾“å…¥è¾“å‡º
      'userJourney',     // ç”¨æˆ·æµç¨‹
      'painPoint'        // ç—›ç‚¹
    ];

    let completedCount = 0;
    let totalWeight = 0;

    for (const field of importantFields) {
      totalWeight += 1;
      if (this.isFieldComplete(extractedInfo[field])) {
        completedCount += 1;
      }
    }

    return completedCount / totalWeight;
  }

  private isFieldComplete(fieldValue: any): boolean {
    if (!fieldValue) return false;
    if (typeof fieldValue === 'string') {
      return fieldValue.trim().length > 5; // è‡³å°‘5ä¸ªå­—ç¬¦
    }
    if (Array.isArray(fieldValue)) {
      return fieldValue.length > 0 && fieldValue.every(item =>
        typeof item === 'string' ? item.trim().length > 3 : true
      );
    }
    return true;
  }

  private identifyMissingCriticalInfo(extractedInfo: ExtractedInfo, criticalInfoTypes: string[]): string[] {
    const missing = []
    for (const infoType of criticalInfoTypes) {
      if (!this.hasRequiredInfo(extractedInfo, infoType)) {
        missing.push(infoType)
      }
    }
    return missing.sort((a, b) => this.getInfoPriority(a) - this.getInfoPriority(b))
  }

  private hasRequiredInfo(extractedInfo: ExtractedInfo, infoType: string): boolean {
    const checkers = {
      'triggerMechanism': () => extractedInfo.userJourney && extractedInfo.userJourney.includes('è§¦å‘'),
      'dataHandling': () => extractedInfo.dataHandling || extractedInfo.inputOutput?.includes('ä¿å­˜'),
      'inputOutput': () => extractedInfo.inputOutput && extractedInfo.inputOutput.length > 10,
      'processFlow': () => extractedInfo.userJourney && extractedInfo.userJourney.includes('â†’'),
      'userRoles': () => extractedInfo.targetUsers && !extractedInfo.targetUsers.includes('ç”¨æˆ·'),
      'workflow': () => extractedInfo.userJourney && extractedInfo.userJourney.includes('æµç¨‹'),
      'userScope': () => extractedInfo.userScope && extractedInfo.userScope !== 'unknown',
    }
    return checkers[infoType]?.() || false
  }

  private async generateCandidateQuestions(
    sessionState: SessionState,
    slotPriorities: SlotPriority[]
  ): Promise<Question[]> {
    const questions: Question[] = []
    const userScope = this.determineUserScope(sessionState.extractedInfo)
    // ä¸ºæ¯ä¸ªé«˜ä¼˜å…ˆçº§æ§½ä½ç”Ÿæˆé—®é¢˜
    for (const slotPriority of slotPriorities.slice(0, 8)) {
      const slot = sessionState.slotStates.find(s => s.slotId === slotPriority.slotId)
      if (!slot) continue
      if (slot.isAmbiguous) {
        // ç”Ÿæˆæ¶ˆæ­§é—®é¢˜
        questions.push(...await this.generateDisambiguationQuestions(slot, sessionState))
      } else if (slot.confidence < 0.7) {
        // ç”Ÿæˆä¿¡æ¯æ”¶é›†é—®é¢˜
        questions.push(...await this.generateInformationGatheringQuestions(slot, userScope, sessionState))
      }
    }
    return questions
  }

  private async generateInformationGatheringQuestions(
    slot: SlotState,
    userScope: string,
    sessionState: SessionState
  ): Promise<Question[]> {
    const questionTemplates = {
      'product_type': {
        personal: {
          question: 'è¿™ä¸ªå·¥å…·ä¸»è¦è§£å†³ä»€ä¹ˆç±»å‹çš„é—®é¢˜ï¼Ÿ',
          options: [
            { id: 'automation', text: 'è‡ªåŠ¨åŒ–å¤„ç†ï¼ˆå‡å°‘æ‰‹åŠ¨æ“ä½œï¼‰' },
            { id: 'information', text: 'ä¿¡æ¯æ•´ç†ï¼ˆæ”¶é›†ã€ç®¡ç†æ•°æ®ï¼‰' },
            { id: 'productivity', text: 'æ•ˆç‡æå‡ï¼ˆç®€åŒ–å·¥ä½œæµç¨‹ï¼‰' },
            { id: 'analysis', text: 'åˆ†æè®¡ç®—ï¼ˆå¤„ç†å¤æ‚é€»è¾‘ï¼‰' },
          ]
        },
        team: {
          question: 'å›¢é˜Ÿä¸»è¦ç”¨è¿™ä¸ªå·¥å…·æ¥åšä»€ä¹ˆï¼Ÿ',
          options: [
            { id: 'collaboration', text: 'åä½œæ²Ÿé€šï¼ˆå›¢é˜Ÿåä½œï¼‰' },
            { id: 'management', text: 'é¡¹ç›®ç®¡ç†ï¼ˆä»»åŠ¡åˆ†é…ã€è¿›åº¦è·Ÿè¸ªï¼‰' },
            { id: 'knowledge', text: 'çŸ¥è¯†ç®¡ç†ï¼ˆæ–‡æ¡£ã€ç»éªŒåˆ†äº«ï¼‰' },
            { id: 'workflow', text: 'å·¥ä½œæµç¨‹ï¼ˆæ ‡å‡†åŒ–æµç¨‹ï¼‰' },
          ]
        },
      },
      'frequency': {
        question: 'æ‚¨é¢„è®¡å¤šä¹…ä½¿ç”¨ä¸€æ¬¡ï¼Ÿ',
        options: [
          { id: 'daily', text: 'æ¯å¤©éƒ½ç”¨' },
          { id: 'weekly', text: 'æ¯å‘¨å‡ æ¬¡' },
          { id: 'monthly', text: 'æ¯æœˆå‡ æ¬¡' },
          { id: 'occasional', text: 'å¶å°”ä½¿ç”¨' },
        ]
      },
      'use_scenario': {
        question: 'èƒ½ç®€å•æè¿°ä¸€ä¸‹å…¸å‹çš„ä½¿ç”¨åœºæ™¯å—ï¼Ÿ',
        type: 'text_simple',
        placeholder: 'ä¾‹å¦‚ï¼šæ¯å¤©æ—©ä¸ŠæŸ¥çœ‹ä»»åŠ¡åˆ—è¡¨ï¼Œå¤„ç†ä¼˜å…ˆçº§é«˜çš„äº‹é¡¹...',
      }
    }
    const template = questionTemplates[slot.slotId]
    if (!template) return []
    const questionData = typeof template === 'object' && template[userScope]
      ? template[userScope]
      : template
    return [
      {
        id: `${slot.slotId}_${Date.now()}`,
        question: questionData.question,
        type: questionData.type || 'single_choice',
        targetSlots: [slot.slotId],
        options: questionData.options,
        placeholder: questionData.placeholder,
        priority: this.calculateInformationGain(slot, sessionState),
        adaptiveLevel: userScope as any
      }
    ]
  }
}
```

### 5. äº§å“ç±»å‹è‡ªé€‚åº”é—®é¢˜åº“

```typescript
const ADAPTIVE_QUESTION_SETS = {
  // ä¸ªäººå°å·¥å…· - æœ€ç®€åŒ–é—®é¢˜
  personal_tool: {
    maxQuestions: 2,
    questions: [
      {
        id: 'usage_frequency',
        question: 'æ‚¨å¤§æ¦‚å¤šä¹…ä¼šä½¿ç”¨ä¸€æ¬¡è¿™ä¸ªå·¥å…·ï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'daily', text: 'æ¯å¤©éƒ½ç”¨', score: 3 },
          { id: 'weekly', text: 'æ¯å‘¨å‡ æ¬¡', score: 2 },
          { id: 'occasional', text: 'å¶å°”ä½¿ç”¨', score: 1 },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.frequency
      },
      {
        id: 'data_persistence',
        question: 'éœ€è¦ä¿å­˜æ‚¨çš„ä½¿ç”¨è®°å½•æˆ–è®¾ç½®å—ï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'no_save', text: 'ä¸éœ€è¦ï¼Œæ¯æ¬¡é‡æ–°å¼€å§‹' },
          { id: 'basic_save', text: 'ä¿å­˜åŸºæœ¬è®¾ç½®' },
          { id: 'full_history', text: 'ä¿å­˜å®Œæ•´ä½¿ç”¨å†å²' },
        ],
        relevanceCheck: (info: ExtractedInfo) => {
          !info.coreFeatures?.some(f => f.includes('ä¿å­˜') || f.includes('è®°å½•'))
        }
      }
    ]
  },
  // å°å›¢é˜Ÿå·¥å…· - ä¸­ç­‰å¤æ‚åº¦
  small_team_tool: {
    maxQuestions: 3,
    questions: [
      {
        id: 'team_size',
        question: 'æ‚¨çš„å›¢é˜Ÿå¤§æ¦‚æœ‰å¤šå°‘äººï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'small', text: '2-5äºº' },
          { id: 'medium', text: '6-15äºº' },
          { id: 'large', text: '16äººä»¥ä¸Š' },
        ],
        relevanceCheck: (info: ExtractedInfo) => info.userScope === 'small_team' && !info.targetUsers?.match(/\d+äºº/)
      },
      {
        id: 'collaboration_level',
        question: 'å›¢é˜Ÿæˆå‘˜ä¹‹é—´éœ€è¦åä½œå—ï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'independent', text: 'å„è‡ªç‹¬ç«‹ä½¿ç”¨' },
          { id: 'share_data', text: 'éœ€è¦å…±äº«æ•°æ®' },
          { id: 'real_time', text: 'éœ€è¦å®æ—¶åä½œ' },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.coreFeatures?.some(f => {
          f.includes('åä½œ') || f.includes('å…±äº«') || f.includes('åŒæ­¥')
        })
      },
      {
        id: 'workflow_steps',
        question: 'èƒ½ç®€å•è¯´è¯´å›¢é˜Ÿä½¿ç”¨è¿™ä¸ªå·¥å…·çš„æµç¨‹å—ï¼Ÿ',
        type: 'text_simple',
        placeholder: 'ä¾‹å¦‚ï¼šåˆ›å»ºä»»åŠ¡ â†’ åˆ†é…ç»™æˆå‘˜ â†’ æ›´æ–°è¿›åº¦ â†’ å®Œæˆç¡®è®¤',
        relevanceCheck: (info: ExtractedInfo) => !info.useScenario
      }
    ]
  },
  // å…¬ä¼—äº§å“ - ç›¸å¯¹å…¨é¢
  public_product: {
    maxQuestions: 4,
    questions: [
      {
        id: 'user_base_expectation',
        question: 'æ‚¨å¸Œæœ›æœ‰å¤šå°‘äººä½¿ç”¨è¿™ä¸ªäº§å“ï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'hundreds', text: 'å‡ ç™¾äºº' },
          { id: 'thousands', text: 'å‡ åƒäºº' },
          { id: 'more', text: 'ä¸Šä¸‡äºº' },
          { id: 'unknown', text: 'ä¸ç¡®å®šï¼Œçœ‹æƒ…å†µ' },
        ],
        relevanceCheck: (info: ExtractedInfo) => info.userScope === 'public'
      },
      {
        id: 'user_account_needed',
        question: 'ç”¨æˆ·éœ€è¦æ³¨å†Œè´¦å·å—ï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'no_account', text: 'ä¸éœ€è¦ï¼Œç›´æ¥ä½¿ç”¨' },
          { id: 'optional', text: 'å¯é€‰ï¼Œæ³¨å†Œåæœ‰æ›´å¤šåŠŸèƒ½' },
          { id: 'required', text: 'å¿…é¡»æ³¨å†Œæ‰èƒ½ä½¿ç”¨' },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.coreFeatures?.some(f => f.includes('æ³¨å†Œ') || f.includes('ç™»å½•'))
      },
      {
        id: 'content_management',
        question: 'ç”¨æˆ·ä¼šåœ¨äº§å“ä¸­åˆ›å»ºæˆ–ç®¡ç†å†…å®¹å—ï¼Ÿ',
        type: 'single_choice',
        options: [
          { id: 'no_content', text: 'ä¸éœ€è¦ï¼Œåªæ˜¯ä½¿ç”¨åŠŸèƒ½' },
          { id: 'simple_content', text: 'ç®€å•çš„å†…å®¹åˆ›å»º' },
          { id: 'rich_content', text: 'å¤æ‚çš„å†…å®¹ç®¡ç†' },
        ],
        relevanceCheck: (info: ExtractedInfo) => !info.coreFeatures?.some(f => {
          f.includes('åˆ›å»º') || f.includes('ç¼–è¾‘') || f.includes('ç®¡ç†')
        })
      },
      {
        id: 'success_measure',
        question: 'å¦‚æœè¿™ä¸ªäº§å“åšå¥½äº†ï¼Œæœ€è®©æ‚¨æ»¡æ„çš„æ˜¯ä»€ä¹ˆï¼Ÿ',
        type: 'text_simple',
        placeholder: 'ä¾‹å¦‚ï¼šç”¨æˆ·è§‰å¾—å¾ˆæœ‰ç”¨ã€è§£å†³äº†å®é™…é—®é¢˜ã€æ“ä½œå¾ˆæ–¹ä¾¿...',
        relevanceCheck: () => true // æ€»æ˜¯è¯¢é—®æˆåŠŸæ ‡å‡†
      }
    ]
  }
}
```

class AdaptiveQuestionGenerator {
  generateQuestions(
    extractedInfo: ExtractedInfo,
    userInputResult: UserInputResult
  ): Question[] {
    // 1. ç¡®å®šäº§å“ç±»å‹å’Œç”¨æˆ·èŒƒå›´
    const userScope = this.determineUserScope(extractedInfo, userInputResult)
    const questionSet = ADAPTIVE_QUESTION_SETS[userScope] || ADAPTIVE_QUESTION_SETS.personal_tool
    // 2. è¿‡æ»¤ç›¸å…³é—®é¢˜
    let relevantQuestions = questionSet.questions.filter(q => {
      q.relevanceCheck(extractedInfo)
    })
    // 3. ç”Ÿæˆåœºæ™¯åŒ–é—®é¢˜ï¼ˆå¦‚æœåŸºç¡€ä¿¡æ¯ä¸è¶³ï¼‰
    const scenarioQuestions = this.generateScenarioQuestions(extractedInfo)
    relevantQuestions = [...relevantQuestions, ...scenarioQuestions]
    // 4. æŒ‰é‡è¦æ€§æ’åºå¹¶é™åˆ¶æ•°é‡
    return relevantQuestions
      .sort((a, b) => (b.priority || 0) - (a.priority || 0))
      .slice(0, questionSet.maxQuestions)
  }

  private determineUserScope(
    extractedInfo: ExtractedInfo,
    userInputResult: UserInputResult
  ): string {
    // 1. å¦‚æœå·²ç»æå–åˆ°ç”¨æˆ·èŒƒå›´ï¼Œç›´æ¥ä½¿ç”¨
    if (extractedInfo.userScope) {
      return `${extractedInfo.userScope}_tool`
    }
    // 2. åŸºäºå…³é”®è¯åˆ†æ
    const text = userInputResult.originalInput.text.toLowerCase()
    const personalKeywords = ['ä¸ªäºº', 'è‡ªå·±', 'æˆ‘çš„', 'è‡ªç”¨']
    const teamKeywords = ['å›¢é˜Ÿ', 'å…¬å¸', 'åŒäº‹', 'åä½œ', 'å°ç»„']
    const publicKeywords = ['ç”¨æˆ·', 'å¤§å®¶', 'å…¬å¼€', 'åˆ†äº«', 'å¹³å°']
    if (personalKeywords.some(keyword => text.includes(keyword))) {
      return 'personal_tool'
    } else if (teamKeywords.some(keyword => text.includes(keyword))) {
      return 'small_team_tool'
    } else if (publicKeywords.some(keyword => text.includes(keyword))) {
      return 'public_product'
    }
    // 3. åŸºäºäº§å“ç±»å‹æ¨æ–­
    const productType = extractedInfo.productType?.toLowerCase() || ''
    if (productType.includes('æ’ä»¶') || productType.includes('å·¥å…·')) {
      return 'personal_tool'
    } else if (productType.includes('ç®¡ç†') || productType.includes('åä½œ')) {
      return 'small_team_tool'
    }
    // 4. é»˜è®¤ä¸ºä¸ªäººå·¥å…·
    return 'personal_tool'
  }

  private generateScenarioQuestions(extractedInfo: ExtractedInfo): Question[] {
    const scenarioQuestions: Question[] = []
    // å¦‚æœç¼ºå°‘æ ¸å¿ƒå·¥ä½œæµç¨‹
    if (!extractedInfo.useScenario) {
      scenarioQuestions.push({
        id: 'simple_workflow',
        question: `å‡è®¾æ‚¨ç°åœ¨å°±è¦ä½¿ç”¨è¿™ä¸ª${extractedInfo.productType || 'å·¥å…·'}ï¼Œæ‚¨ä¼šæ€ä¹ˆæ“ä½œï¼Ÿ`,
        type: 'text_simple',
        placeholder: 'ä¾‹å¦‚ï¼šæ‰“å¼€å·¥å…· â†’ è¾“å…¥å†…å®¹ â†’ ç‚¹å‡»å¤„ç† â†’ æŸ¥çœ‹ç»“æœ',
        priority: 10
      })
    }
    // å¦‚æœç¼ºå°‘ç—›ç‚¹ä¿¡æ¯
    if (!extractedInfo.painPoint && !extractedInfo.currentSolution) {
      scenarioQuestions.push({
        id: 'current_solution',
        question: 'æ‚¨ç°åœ¨æ˜¯æ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜çš„ï¼Ÿæœ‰ä»€ä¹ˆä¸æ–¹ä¾¿çš„åœ°æ–¹ï¼Ÿ',
        type: 'text_simple',
        placeholder: 'ä¾‹å¦‚ï¼šç°åœ¨è¦æ‰‹åŠ¨è®¡ç®—ï¼Œå¾ˆéº»çƒ¦...',
        priority: 8
      })
    }
    return scenarioQuestions
  }
}
```

### 3. é—®ç­”äº¤äº’ç•Œé¢

```typescript
const SmartQuestioningInterface = ( {
  questions,
  onAnswersComplete
}: {
  questions: Question[],
  onAnswersComplete: (answers: Answer[]) => void
}) => {
  const [currentIndex, setCurrentIndex] = useState(0)
  const [answers, setAnswers] = useState<Answer[]>([])
  const [isAnimating, setIsAnimating] = useState(false)
  const handleAnswer = async (answer: AnswerValue) => {
    const newAnswer: Answer = {
      questionId: questions[currentIndex].id,
      value: answer,
      timestamp: new Date()
    }
    const newAnswers = [...answers, newAnswer]
    setAnswers(newAnswers)
    // åŠ¨ç”»æ•ˆæœ
    setIsAnimating(true)
    await new Promise(resolve => setTimeout(resolve, 300))
    if (currentIndex < questions.length - 1) {
      setCurrentIndex(currentIndex + 1)
    } else {
      onAnswersComplete(newAnswers)
    }
    setIsAnimating(false)
  }

  const currentQuestion = questions[currentIndex]
  return (
    <div className="smart-questioning-interface">
      <div className="progress-bar">
        <div>
          <div className="progress-fill" style={{ width: `${((currentIndex + 1) / questions.length) * 100}%` }}></div>
          <span className="progress-text">{currentIndex + 1} / {questions.length}</span>
        </div>
      </div>
      <div className={`question-container ${isAnimating ? 'animating' : ''}`}>
        <div className="question-card">
          <h3 className="question-title">{currentQuestion.question}</h3>
          {currentQuestion.type === 'single_choice' && (
            <div className="choice-options">
              {currentQuestion.options?.map((option, index) => (
                <button
                  key={option.id}
                  className="choice-button"
                  onClick={() => handleAnswer(option.id)}
                >
                  {option.text}
                </button>
              ))}
            </div>
          )}
          {currentQuestion.type === 'text_simple' && (
            <div className="text-input-section">
              <textarea
                placeholder={currentQuestion.placeholder}
                className="simple-text-input"
                onKeyPress={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault()
                    const value = (e.target as HTMLTextAreaElement).value.trim()
                    if (value) {
                      handleAnswer(value)
                    }
                  }
                }
              />
              <div className="text-input-actions">
                <button
                  onClick={() => {
                    const textarea = document.querySelector('.simple-text-input') as HTMLTextAreaElement
                    const value = textarea.value.trim()
                    if (value) {
                      handleAnswer(value)
                    }
                  }}
                  className="submit-text-button"
                >
                  ç¡®è®¤
                </button>
              </div>
            </div>
          )}
        </div>
        {/* å·²å›ç­”é—®é¢˜çš„é¢„è§ˆ */
        <div className="answered-questions">
          {answers.map((answer, index) => (
            <div key={index} className="answered-item">
              <span className="answered-question">
                {questions.find(q => q.id === answer.questionId)?.question}
              </span>
              <span className="answered-value">
                {formatAnswerValue(answer.value)}
              </span>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

### 4. åŠ¨æ€é—®é¢˜ç”Ÿæˆæ§åˆ¶å™¨

```typescript
class DynamicQuestioningController {
  async processUserAnswers(
    answers: Answer[],
    sessionState: SessionState
  ): Promise<QuestioningDecision> {
    // 1. æ›´æ–°ä¿¡æ¯çŠ¶æ€
    const updatedInfo = await this.updateExtractedInfo(sessionState.extractedInfo, answers)

    // 2. é‡æ–°è¯„ä¼°å®Œæ•´æ€§
    const newCompleteness = this.evaluateInformationCompleteness({
      ...sessionState,
      extractedInfo: updatedInfo
    })

    // 3. æ™ºèƒ½å†³ç­–ï¼šç»§ç»­é—®ç­” vs è¿›å…¥ç¡®è®¤
    if (this.shouldContinueQuestioning(updatedInfo, sessionState.questionCount, newCompleteness)) {
      // ç”Ÿæˆä¸‹ä¸€è½®é—®é¢˜
      const nextQuestions = await this.generateNextQuestions(updatedInfo, sessionState.questionCount + 1)
      return {
        action: 'continue_questioning',
        questions: nextQuestions,
        extractedInfo: updatedInfo,
        completeness: newCompleteness,
        reason: this.explainContinueReason(newCompleteness)
      }
    } else {
      // è¿›å…¥éœ€æ±‚ç¡®è®¤
      return {
        action: 'proceed_to_confirmation',
        extractedInfo: updatedInfo,
        completeness: newCompleteness,
        confidence: newCompleteness.overall
      }
    }
  }

  private async generateNextQuestions(
    extractedInfo: ExtractedInfo,
    questionCount: number
  ): Promise<Question[]> {
    // åŸºäºä¿¡æ¯å®Œæ•´æ€§ç”Ÿæˆé—®é¢˜
    const missingCritical = this.identifyMissingCriticalInfo(extractedInfo)
    const missingImportant = this.identifyMissingImportantInfo(extractedInfo)

    const questions: Question[] = []

    // ä¼˜å…ˆå¤„ç†å…³é”®ä¿¡æ¯ç¼ºå¤±
    if (missingCritical.length > 0) {
      questions.push(...await this.generateCriticalQuestions(missingCritical, extractedInfo))
    }

    // ç„¶åå¤„ç†é‡è¦ä¿¡æ¯ç¼ºå¤±
    if (questions.length < 2 && missingImportant.length > 0) {
      questions.push(...await this.generateImportantQuestions(missingImportant, extractedInfo))
    }

    // é™åˆ¶é—®é¢˜æ•°é‡ï¼ˆé¿å…ç”¨æˆ·ç–²åŠ³ï¼‰
    const maxQuestions = Math.max(1, 4 - Math.floor(questionCount / 2))
    return questions.slice(0, maxQuestions)
  }

  private explainContinueReason(completeness: InformationCompleteness): string {
    if (completeness.critical < 0.85) {
      return 'æ ¸å¿ƒä¿¡æ¯ä¸è¶³ï¼Œéœ€è¦ç»§ç»­æ”¶é›†'
    }
    if (completeness.important < 0.75) {
      return 'é‡è¦ä¿¡æ¯ä¸å®Œæ•´ï¼Œå»ºè®®è¡¥å……'
    }
    if (completeness.overall < 0.8) {
      return 'æ•´ä½“ä¿¡æ¯è¿˜éœ€è¦å®Œå–„'
    }
    return 'ä¿¡æ¯æ”¶é›†å®Œæˆ'
  }
}
```

### 5. æ™ºèƒ½å®Œæ•´æ€§è¯„ä¼°å™¨

```typescript
interface InformationCompleteness {
  critical: number;    // å…³é”®ä¿¡æ¯å®Œæ•´åº¦ (0-1)
  important: number;   // é‡è¦ä¿¡æ¯å®Œæ•´åº¦ (0-1)
  optional: number;    // å¯é€‰ä¿¡æ¯å®Œæ•´åº¦ (0-1)
  overall: number;     // æ•´ä½“å®Œæ•´åº¦ (0-1)
}

class IntelligentCompletenessChecker {
  evaluateInformationCompleteness(extractedInfo: ExtractedInfo): InformationCompleteness {
    const critical = this.evaluateCriticalInfoCompleteness(extractedInfo);
    const important = this.evaluateImportantInfoCompleteness(extractedInfo);
    const optional = this.evaluateOptionalInfoCompleteness(extractedInfo);

    // åŠ æƒè®¡ç®—æ•´ä½“å®Œæ•´åº¦
    const overall = critical * 0.6 + important * 0.3 + optional * 0.1;

    return {
      critical,
      important,
      optional,
      overall
    };
  }

  shouldProceedToConfirmation(completeness: InformationCompleteness, questionCount: number): boolean {
    // å…³é”®ä¿¡æ¯å¿…é¡»å……è¶³
    if (completeness.critical < 0.85) return false;

    // é‡è¦ä¿¡æ¯åŸºæœ¬å……è¶³ + ä¸è¦è¿‡åº¦è¯¢é—®
    if (completeness.important >= 0.75 || questionCount >= 6) return true;

    // æ•´ä½“ä¿¡æ¯å……è¶³
    if (completeness.overall >= 0.8) return true;

    return false;
  }

  private evaluateOptionalInfoCompleteness(extractedInfo: ExtractedInfo): number {
    const optionalFields = [
      'performanceRequirements',  // æ€§èƒ½è¦æ±‚
      'integrationNeeds',        // é›†æˆéœ€æ±‚
      'constraints',             // çº¦æŸæ¡ä»¶
      'successCriteria'          // æˆåŠŸæ ‡å‡†
    ];

    let completedCount = 0;
    let totalWeight = 0;

    for (const field of optionalFields) {
      totalWeight += 1;
      if (this.isFieldComplete(extractedInfo[field])) {
        completedCount += 1;
      }
    }

    return totalWeight > 0 ? completedCount / totalWeight : 1;
  }
          <div className="complexity-section">
            <h3>æŠ€æœ¯å¤æ‚åº¦</h3>
            <span className={`complexity-badge ${summary.technicalLevel}`}>
              {getComplexityLabel(summary.technicalLevel)}
            </span>
          </div>
        </div>
        <div className="features-section">
          <h3>ä¸»è¦åŠŸèƒ½</h3>
          {summary.mainFeatures.map((feature, index) => (
            <div key={index} className="feature-item">
              <div className="feature-content">
                <span className="feature-name">{feature.name}</span>
                <span className="feature-desc">{feature.description}</span>
                {feature.essential && <span className="essential-badge">æ ¸å¿ƒ</span>}
              </div>
              <div className="feature-actions">
                <button onClick={() => toggleAdjustment('modify_feature', feature, index)}>
                  ä¿®æ”¹
                </button>
                <button onClick={() => toggleAdjustment('remove_feature', feature, index)}>
                  åˆ é™¤
                </button>
              </div>
            </div>
          ))}
          <button
            className="add-feature-button"
            onClick={() => toggleAdjustment('add_feature')}
          >
            + æ·»åŠ åŠŸèƒ½
          </button>
        </div>
      </div>
      {/* è°ƒæ•´é¢æ¿ */
      {selectedAdjustments.length > 0 && (
        <div className="adjustment-panel">
          <h4>éœ€è¦è°ƒæ•´çš„å†…å®¹</h4>
          {selectedAdjustments.map((adj, index) => (
            <AdjustmentItem
              key={index}
              adjustment={adj}
              onUpdate={(updated) => updateAdjustment(index, updated)}
              onRemove={() => removeAdjustment(index)}
            />
          ))}
          <div className="adjustment-actions">
            <button onClick={() => onAdjust(selectedAdjustments)}>
              åº”ç”¨è°ƒæ•´
            </button>
            <button onClick={() => setSelectedAdjustments([])}>
              å–æ¶ˆ
            </button>
          </div>
        </div>
      )}
      <div className="confirmation-actions">
        <button onClick={onConfirm} className="primary-confirm-btn">
          âœ… ç†è§£å‡†ç¡®ï¼Œç”ŸæˆPRD
        </button>
        <button onClick={() => setShowAdjustmentHelp(true)} className="secondary-adjust-btn">
          ğŸ”§ éœ€è¦å¾®è°ƒ
        </button>
        <button onClick={onRestart} className="restart-btn">
          ğŸ”„ é‡æ–°å¼€å§‹é—®ç­”
        </button>
      </div>
    </div>
  )
}
```

## å®Œæ•´æµç¨‹ç¤ºä¾‹

### ç¤ºä¾‹ï¼šæµè§ˆå™¨æ’ä»¶é¡¹ç›®

#### Step 1: æ¥æ”¶ç”¨æˆ·è¾“å…¥ç»“æœ

```typescript
const userInputResult: UserInputResult = {
  originalInput: {
    text: "æˆ‘æƒ³åšä¸€ä¸ªæµè§ˆå™¨æ’ä»¶ï¼Œå¯ä»¥è‡ªåŠ¨æå–ç½‘é¡µä¸­çš„é‚®ç®±åœ°å€ï¼Œæˆ‘ç»å¸¸éœ€è¦æ”¶é›†å®¢æˆ·é‚®ç®±ï¼Œç°åœ¨è¦æ‰‹åŠ¨å¤åˆ¶ç²˜è´´å¾ˆéº»çƒ¦",
    images: [],
    timestamp: new Date()
  },
  multimodalAnalysis: {
    textSummary: "ç”¨æˆ·æƒ³å¼€å‘æµè§ˆå™¨æ’ä»¶æ¥è‡ªåŠ¨æå–ç½‘é¡µé‚®ç®±åœ°å€",
    imageDescriptions: [],
    extractedText: [],
    combinedContext: "æˆ‘æƒ³åšä¸€ä¸ªæµè§ˆå™¨æ’ä»¶ï¼Œå¯ä»¥è‡ªåŠ¨æå–ç½‘é¡µä¸­çš„é‚®ç®±åœ°å€ï¼Œæˆ‘ç»å¸¸éœ€è¦æ”¶é›†å®¢æˆ·é‚®ç®±ï¼Œç°åœ¨è¦æ‰‹åŠ¨å¤åˆ¶ç²˜è´´å¾ˆéº»çƒ¦",
    confidence: 0.95
  },
  validation: {
    isValid: true,
    hasContent: true,
    wordCount: 45,
    issues: []
  }
};
```

#### Step 2: æ™ºèƒ½ä¿¡æ¯æå–

```typescript
const extractedInfo: ExtractedInfo = {
  productType: "æµè§ˆå™¨æ’ä»¶",
  coreGoal: "è‡ªåŠ¨æå–ç½‘é¡µä¸­çš„é‚®ç®±åœ°å€ï¼Œæé«˜æ”¶é›†æ•ˆç‡",
  targetUsers: "ç»å¸¸éœ€è¦æ”¶é›†å®¢æˆ·é‚®ç®±çš„ä¸ªäººç”¨æˆ·",
  userScope: "personal",
  coreFeatures: ["è‡ªåŠ¨è¯†åˆ«ç½‘é¡µé‚®ç®±", "ä¸€é”®æå–åŠŸèƒ½"],
  useScenario: "æ”¶é›†å®¢æˆ·é‚®ç®±æ—¶ä½¿ç”¨",
  userJourney: "æ‰“å¼€ç½‘é¡µ â†’ ç‚¹å‡»æ’ä»¶ â†’ è‡ªåŠ¨æå–é‚®ç®± â†’ å¤åˆ¶æˆ–ä¿å­˜",
  inputOutput: "è¾“å…¥ï¼šå½“å‰ç½‘é¡µå†…å®¹ï¼Œè¾“å‡ºï¼šæå–çš„é‚®ç®±åœ°å€åˆ—è¡¨",
  painPoint: "æ‰‹åŠ¨å¤åˆ¶ç²˜è´´å¾ˆéº»çƒ¦",
  currentSolution: "æ‰‹åŠ¨æŸ¥æ‰¾å’Œå¤åˆ¶ç²˜è´´é‚®ç®±åœ°å€",
  technicalHints: ["æµè§ˆå™¨æ’ä»¶", "ç½‘é¡µå†…å®¹è§£æ"],
  integrationNeeds: [],
  performanceRequirements: "å¿«é€Ÿè¯†åˆ«ï¼Œå‡†ç¡®æå–"
};
```

#### Step 3: è¯„ä¼°ä¿¡æ¯å®Œæ•´æ€§ï¼Œç”Ÿæˆé’ˆå¯¹æ€§é—®é¢˜

```typescript
// å®Œæ•´æ€§è¯„ä¼°
const completeness: InformationCompleteness = {
  critical: 0.9,    // å…³é”®ä¿¡æ¯å……è¶³ï¼šäº§å“ç±»å‹ã€ç›®æ ‡ã€ç”¨æˆ·ã€æ ¸å¿ƒåŠŸèƒ½
  important: 0.7,   // é‡è¦ä¿¡æ¯ç¼ºå¤±ï¼šä½¿ç”¨é¢‘ç‡ã€æ•°æ®ä¿å­˜æ–¹å¼
  optional: 0.4,    // å¯é€‰ä¿¡æ¯ç¼ºå¤±ï¼šæ€§èƒ½è¦æ±‚ã€é›†æˆéœ€æ±‚
  overall: 0.78     // æ•´ä½“å®Œæ•´åº¦
};

// ç”Ÿæˆé—®é¢˜ï¼ˆå› ä¸ºimportant < 0.75ï¼Œéœ€è¦è¡¥å……ï¼‰
const questions: Question[] = [
  {
    id: 'usage_frequency_001',
    question: "æ‚¨å¤§æ¦‚å¤šä¹…ä¼šä½¿ç”¨ä¸€æ¬¡è¿™ä¸ªæ’ä»¶ï¼Ÿ",
    type: 'single_choice',
    options: [
      { id: 'daily', text: 'æ¯å¤©éƒ½ç”¨' },
      { id: 'weekly', text: 'æ¯å‘¨å‡ æ¬¡' },
      { id: 'occasional', text: 'å¶å°”ä½¿ç”¨' }
    ],
    targetSlots: ['usage_frequency'],
    priority: 8
  },
  {
    id: 'data_handling_001',
    question: "æå–çš„é‚®ç®±åœ°å€éœ€è¦ä¿å­˜å—ï¼Ÿ",
    type: 'single_choice',
    options: [
      { id: 'no_save', text: 'ä¸éœ€è¦ï¼Œç›´æ¥å¤åˆ¶ä½¿ç”¨' },
      { id: 'local_file', text: 'ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶' },
      { id: 'history', text: 'ä¿å­˜æå–å†å²è®°å½•' }
    ],
    targetSlots: ['data_persistence'],
    priority: 7
  }
];
```

#### Step 4: å¤„ç†ç”¨æˆ·ç­”æ¡ˆï¼Œå®Œæˆä¿¡æ¯æ”¶é›†

```typescript
const answers: Answer[] = [
  {
    questionId: 'usage_frequency_001',
    value: 'weekly',
    timestamp: new Date()
  },
  {
    questionId: 'data_handling_001',
    value: 'local_file',
    timestamp: new Date()
  }
];

// æ›´æ–°æå–ä¿¡æ¯
const finalExtractedInfo: ExtractedInfo = {
  ...extractedInfo,
  // åŸºäºç­”æ¡ˆæ›´æ–°ä¿¡æ¯
  useScenario: "æ¯å‘¨å‡ æ¬¡æ”¶é›†å®¢æˆ·é‚®ç®±æ—¶ä½¿ç”¨",
  coreFeatures: [
    "è‡ªåŠ¨è¯†åˆ«ç½‘é¡µé‚®ç®±",
    "ä¸€é”®æå–åŠŸèƒ½",
    "ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶"
  ],
  dataHandling: "ä¿å­˜æå–ç»“æœåˆ°æœ¬åœ°Excelæˆ–CSVæ–‡ä»¶"
};

// é‡æ–°è¯„ä¼°å®Œæ•´æ€§
const finalCompleteness: InformationCompleteness = {
  critical: 0.9,
  important: 0.85,  // é‡è¦ä¿¡æ¯ç°åœ¨å……è¶³äº†
  optional: 0.5,
  overall: 0.83     // æ•´ä½“å®Œæ•´åº¦è¾¾æ ‡
};
```

#### Step 5: ç”Ÿæˆæœ€ç»ˆè¾“å‡º

```typescript
const questioningResult: SmartQuestioningResult = {
  extractedInfo: finalExtractedInfo,
  questioningSession: {
    questions,
    answers,
    totalRounds: 1,
    duration: 120, // 120ç§’
    completionReason: "ä¿¡æ¯å®Œæ•´åº¦è¾¾æ ‡(83%)"
  },
  completeness: finalCompleteness,
  userInputResult,
  validation: {
    extractionConfidence: 0.9,
    questioningQuality: 0.85,
    readyForConfirmation: true
  }
};
```

## è¾“å‡ºæ¥å£

```typescript
interface SmartQuestioningResult {
  // æ ¸å¿ƒæå–ä¿¡æ¯
  extractedInfo: ExtractedInfo;

  // é—®ç­”ä¼šè¯æ•°æ®
  questioningSession: {
    questions: Question[];
    answers: Answer[];
    totalRounds: number;
    duration: number;
    completionReason: string;
  };

  // ä¿¡æ¯å®Œæ•´æ€§è¯„ä¼°
  completeness: {
    critical: number;      // å…³é”®ä¿¡æ¯å®Œæ•´åº¦ (0-1)
    important: number;     // é‡è¦ä¿¡æ¯å®Œæ•´åº¦ (0-1)
    optional: number;      // å¯é€‰ä¿¡æ¯å®Œæ•´åº¦ (0-1)
    overall: number;       // æ•´ä½“å®Œæ•´åº¦ (0-1)
  };

  // ç”¨æˆ·è¾“å…¥åŸå§‹æ•°æ®
  userInputResult: UserInputResult;

  // è´¨é‡éªŒè¯
  validation: {
    extractionConfidence: number;  // ä¿¡æ¯æå–ç½®ä¿¡åº¦
    questioningQuality: number;    // é—®ç­”è´¨é‡è¯„åˆ†
    readyForConfirmation: boolean; // æ˜¯å¦å‡†å¤‡å¥½è¿›å…¥ç¡®è®¤é˜¶æ®µ
  };
}

interface ExtractedInfo {
  // äº§å“åŸºç¡€ä¿¡æ¯
  productType: string;           // äº§å“ç±»å‹
  coreGoal: string;             // æ ¸å¿ƒç›®æ ‡
  targetUsers: string;          // ç›®æ ‡ç”¨æˆ·
  userScope: 'personal' | 'small_team' | 'public';

  // åŠŸèƒ½ç›¸å…³ä¿¡æ¯
  coreFeatures: string[];       // æ ¸å¿ƒåŠŸèƒ½åˆ—è¡¨
  useScenario: string;          // ä½¿ç”¨åœºæ™¯
  userJourney: string;          // ç”¨æˆ·æµç¨‹
  inputOutput: string;          // è¾“å…¥è¾“å‡ºæè¿°

  // ä¸Šä¸‹æ–‡ä¿¡æ¯
  painPoint: string;            // ç”¨æˆ·ç—›ç‚¹
  currentSolution: string;      // ç°æœ‰è§£å†³æ–¹æ¡ˆ

  // æŠ€æœ¯ç›¸å…³
  technicalHints: string[];     // æŠ€æœ¯çº¿ç´¢
  integrationNeeds: string[];   // é›†æˆéœ€æ±‚
  performanceRequirements: string; // æ€§èƒ½è¦æ±‚
  dataHandling?: string;        // æ•°æ®å¤„ç†æ–¹å¼ï¼ˆå¯é€‰ï¼‰
}

interface Question {
  id: string;
  question: string;
  type: 'single_choice' | 'text_simple';
  options?: { id: string; text: string }[];
  placeholder?: string;
  targetSlots: string[];
  priority: number;
}

interface Answer {
  questionId: string;
  value: string;
  timestamp: Date;
}
```

## å…³é”®ç‰¹æ€§

### âœ… **AIæ™ºèƒ½åˆ†æå¯¹è¯å†å²**
- é¿å…é‡å¤è¯¢é—®æ˜¾è€Œæ˜“è§çš„ä¿¡æ¯
- ä»ç”¨æˆ·æè¿°ä¸­æ™ºèƒ½æ¨æ–­äº§å“ç±»å‹ã€ç”¨æˆ·ç¾¤ä½“ç­‰åŸºç¡€ä¿¡æ¯
- åŸºäºä¿¡æ¯å®Œæ•´æ€§åŠ¨æ€è°ƒæ•´é—®é¢˜ç­–ç•¥

### âœ… **åŸºäºPRDéœ€æ±‚ç²¾å‡†æ”¶é›†ä¿¡æ¯**
- é—®é¢˜ç›´æ¥å¯¹åº”PRDç”Ÿæˆæ‰€éœ€çš„æ ¸å¿ƒä¿¡æ¯
- é¿å…å•†ä¸šèƒŒæ™¯ã€ç«å“åˆ†æç­‰ä¼ ç»ŸPRDå†…å®¹
- å¼ºåŒ–åŠŸèƒ½å®ç°ç›¸å…³ä¿¡æ¯æ”¶é›†

### âœ… **åŸºäºä¿¡æ¯å®Œæ•´æ€§çš„æ™ºèƒ½é—®ç­”ç­–ç•¥**
- å®æ—¶è¯„ä¼°å…³é”®ä¿¡æ¯ã€é‡è¦ä¿¡æ¯ã€å¯é€‰ä¿¡æ¯çš„å®Œæ•´åº¦
- æ™ºèƒ½å†³å®šæ˜¯å¦ç»§ç»­æé—®ï¼Œè€Œéé¢„è®¾é—®é¢˜æ•°é‡
- é˜²æ­¢è¿‡åº¦è¯¢é—®çš„å®‰å…¨æœºåˆ¶ï¼ˆæœ€å¤š8è½®å¯¹è¯ï¼‰
- 85%å…³é”®ä¿¡æ¯å®Œæ•´åº¦é—¨æ§›ï¼Œç¡®ä¿PRDç”Ÿæˆè´¨é‡

### âœ… **é¢å‘AI Codingåœºæ™¯ä¼˜åŒ–**
- å¼±åŒ–ä¼ ç»ŸPRDçš„å•†ä¸šè®ºè¯éƒ¨åˆ†
- å¼ºåŒ–æŠ€æœ¯å®ç°å’ŒåŠŸèƒ½ç»†èŠ‚æ”¶é›†
- é€‚åˆ"ç”¨Cursoråˆ¶ä½œææ•ˆå·¥å…·"çš„ä½¿ç”¨åœºæ™¯

## ä¸åç»­æ¨¡å—çš„æ¥å£

### è¾“å…¥ï¼šæ¥è‡ªç”¨æˆ·è¾“å…¥æ¨¡å—
- `UserInputResult`ï¼šç”¨æˆ·çš„åŸå§‹éœ€æ±‚æè¿°ï¼ˆæ–‡æœ¬+å›¾ç‰‡ï¼‰

### è¾“å‡ºï¼šä¼ é€’ç»™éœ€æ±‚ç¡®è®¤æ¨¡å—
æ™ºèƒ½é—®ç­”æ¨¡å—å®Œæˆåï¼Œè¾“å‡º `SmartQuestioningResult` ç»™**éœ€æ±‚ç¡®è®¤æ¨¡å—ï¼ˆ03æ¨¡å—ï¼‰**ï¼ŒåŒ…å«ï¼š

1. **æå–çš„éœ€æ±‚ä¿¡æ¯**ï¼šç»è¿‡AIåˆ†æå’Œé—®ç­”è¡¥å……çš„ç»“æ„åŒ–éœ€æ±‚ä¿¡æ¯
2. **é—®ç­”ä¼šè¯è®°å½•**ï¼šå®Œæ•´çš„é—®é¢˜å’Œç­”æ¡ˆå†å²ï¼Œä¾›åç»­å‚è€ƒ
3. **ä¿¡æ¯å®Œæ•´æ€§è¯„ä¼°**ï¼šå„ç»´åº¦ä¿¡æ¯çš„å®Œæ•´åº¦è¯„åˆ†ï¼Œå¸®åŠ©åˆ¤æ–­è´¨é‡
4. **åŸå§‹è¾“å…¥æ•°æ®**ï¼šä¿ç•™ç”¨æˆ·æœ€åˆçš„éœ€æ±‚æè¿°ï¼Œä¾›éœ€æ±‚ç¡®è®¤æ—¶å‚è€ƒ

**æ³¨æ„**ï¼šæœ¬æ¨¡å—**ä¸è´Ÿè´£**éœ€æ±‚ç¡®è®¤å’Œæ€»ç»“ç”Ÿæˆï¼Œè¿™äº›å·¥ä½œç”±03æ¨¡å—å®Œæˆã€‚
