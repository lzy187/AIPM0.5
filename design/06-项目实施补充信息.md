# AIäº§å“ç»ç† - é¡¹ç›®å®æ–½ç®€åŒ–æ–¹æ¡ˆ

## ğŸ¯ å®æ–½ç†å¿µ

**ç›®æ ‡**: ç”¨ç®€åŒ–çš„æŠ€æœ¯æ¶æ„å®ç°å„æ¨¡å—è®¾è®¡çš„å®Œæ•´åŠŸèƒ½ï¼Œä¸å¼±åŒ–ä»»ä½•ç”¨æˆ·ä½“éªŒ

### æ ¸å¿ƒåŸåˆ™

- âœ… **ä¿æŒåŠŸèƒ½å®Œæ•´**: å®Œå…¨å®ç°02-05æ¨¡å—è®¾è®¡çš„æ‰€æœ‰åŠŸèƒ½
- âœ… **ä¿æŒä½“éªŒä¼˜é›…**: å®Œå…¨å®ç°å‰ç«¯äº¤äº’è®¾è®¡çš„ä½“éªŒ
- âœ… **ç®€åŒ–æŠ€æœ¯æ¶æ„**: ç”¨æ›´å°‘çš„æŠ€æœ¯å¤æ‚åº¦å®ç°ç›¸åŒæ•ˆæœ
- âœ… **åŠ é€Ÿå¼€å‘è¿›åº¦**: å‡å°‘é…ç½®å’Œéƒ¨ç½²å¤æ‚åº¦

## ğŸ› ï¸ æŠ€æœ¯æ¶æ„ç®€åŒ–ç­–ç•¥

```typescript
const IMPLEMENTATION_STRATEGY = {
  // ä¿æŒåŠŸèƒ½è®¾è®¡ä¸å˜ï¼Œç®€åŒ–æŠ€æœ¯å®ç°
  approach: 'Keep Design, Simplify Tech',
  // å„æ¨¡å—å®ç°ç­–ç•¥
  modules: {
    '02-æ™ºèƒ½é—®ç­”': 'å®Œæ•´å®ç°æ‰€æœ‰æ™ºèƒ½é€»è¾‘ï¼Œç”¨å†…å­˜æ›¿ä»£æ•°æ®åº“',
    '03-éœ€æ±‚ç¡®è®¤': 'å®Œæ•´å®ç°ç¡®è®¤ç•Œé¢ï¼Œç”¨ReactçŠ¶æ€ç®¡ç†',
    '04-PRDç”Ÿæˆ': 'å®Œæ•´å®ç°PRDè´¨é‡ï¼Œç”¨å‰ç«¯æ–‡ä»¶å¤„ç†',
    '05-AIç¼–ç¨‹': 'å®Œæ•´å®ç°æ–¹æ¡ˆç”Ÿæˆï¼Œç”¨Markdownæ ¼å¼',
    'å‰ç«¯äº¤äº’': 'å®Œæ•´å®ç°åŠ¨æ€ä½“éªŒï¼Œç”¨çº¯CSSåŠ¨ç”»'
  },
  // ç®€åŒ–ç‚¹ï¼šæŠ€æœ¯æ ˆé€‰æ‹©
  simplifications: {
    database: 'å†…å­˜ + localStorage æ›¿ä»£ PostgreSQL',
    files: 'å‰ç«¯å¤„ç† æ›¿ä»£ åç«¯æ–‡ä»¶æœåŠ¡',
    deployment: 'Vercel ä¸€é”®éƒ¨ç½²',
    apis: 'é›†æˆç›¸å…³APIç«¯ç‚¹å‡å°‘ç½‘ç»œè°ƒç”¨'
  }
}
```

## ğŸ“¦ æ•°æ®å±‚ç®€åŒ–å®ç°

### ä¿æŒ02æ¨¡å—å®Œæ•´æ•°æ®ç»“æ„ï¼Œç®€åŒ–å­˜å‚¨æ–¹å¼

```typescript
// ğŸ¯ ä¿æŒå„æ¨¡å—è®¾è®¡çš„å®Œæ•´æ•°æ®ç»“æ„ï¼Œæ­£ç¡®å¯¼å…¥
import {
  ExtractedInfo,
  QuestioningSession,
  SmartQuestioningResult
} from './02-æ™ºèƒ½é—®ç­”æ¨¡å—';
import {
  RequirementSummary,
  FactsDigest,
  AdjustmentRequest,
  RequirementConfirmationResult
} from './03-éœ€æ±‚ç¡®è®¤æ¨¡å—';
import {
  HighQualityPRD,
  PRDQualityReport
} from './04-PRDæ¨¡å—';

// ğŸ¯ ç”¨ç®€å•çš„å†…å­˜ç®¡ç†æ›¿ä»£æ•°æ®åº“ï¼Œä½†ä¿æŒå®Œæ•´åŠŸèƒ½
class SimpleDataManager {
  // ä¿æŒæ‰€æœ‰02æ¨¡å—å®šä¹‰çš„æ•°æ®ç»“æ„
  private sessions = new Map<string, QuestioningSession>();
  private extractedInfo = new Map<string, ExtractedInfo>();
  private confirmationResults = new Map<string, RequirementConfirmationResult>();
  private prdDocuments = new Map<string, HighQualityPRD>();
  private qualityReports = new Map<string, PRDQualityReport>();

  // å®ç°02æ¨¡å—å®šä¹‰çš„æ‰€æœ‰æ•°æ®æ“ä½œæ–¹æ³•
  async createQuestioningSession(userInput: string): Promise<QuestioningSession> {
    // å®Œæ•´å®ç°02æ¨¡å—çš„ä¼šè¯åˆ›å»ºé€»è¾‘
    const session: QuestioningSession = {
      id: this.generateId(),
      extractedInfo: null,
      questionRounds: [],
      completeness: {
        critical: 0,      // å…³é”®ä¿¡æ¯å®Œæ•´åº¦
        important: 0,     // é‡è¦ä¿¡æ¯å®Œæ•´åº¦
        optional: 0,      // å¯é€‰ä¿¡æ¯å®Œæ•´åº¦
        overall: 0        // æ•´ä½“å®Œæ•´åº¦
      },
      currentState: 'INFO_EXTRACTED',
      userInputResult: { originalInput: { text: userInput } }
    };

    this.sessions.set(session.id, session);

    // å¯é€‰çš„æœ¬åœ°å­˜å‚¨å¤‡ä»½
    this.saveToLocalStorage('session', session.id, session);

    return session;
  }

  // ... å®ç°æ‰€æœ‰å…¶ä»–æ¨¡å—å®šä¹‰çš„æ•°æ®æ“ä½œæ–¹æ³•

  // å…³é”®ï¼šä¿æŒæ¥å£å®Œå…¨ä¸€è‡´ï¼Œåªæ˜¯å­˜å‚¨æ–¹å¼ä»æ•°æ®åº“æ”¹ä¸ºå†…å­˜
}

```

## ğŸ”Œ APIå±‚ä¼˜åŒ–å®ç°

### ä¿æŒå„æ¨¡å—åŠŸèƒ½å®Œæ•´ï¼Œä¼˜åŒ–APIè°ƒç”¨

```typescript
// ğŸ¯ å®ç°02æ¨¡å—è®¾è®¡çš„å®Œæ•´æ™ºèƒ½é—®ç­”é€»è¾‘
// app/api/questioning/route.ts
export async function POST(request: Request) {
  const { message, sessionId } = await request.json();

  // å®Œæ•´å®ç°02æ¨¡å—çš„æ™ºèƒ½ä¿¡æ¯æå–å¼•æ“
  const infoExtractor = new IntelligentInfoExtractor();
  const extractedInfo = await infoExtractor.extractFromUserInput({
    originalInput: { text: message }
  });

  // å®Œæ•´å®ç°02æ¨¡å—çš„åŠ¨æ€é—®é¢˜ç”Ÿæˆæ§åˆ¶å™¨
  const questioningController = new DynamicQuestioningController();
  const questioningDecision = await questioningController.processUserAnswers(
    answers,
    sessionState
  );

  // å®Œæ•´å®ç°02æ¨¡å—çš„æ™ºèƒ½å®Œæ•´æ€§è¯„ä¼°å™¨
  const completenessChecker = new IntelligentCompletenessChecker();
  const completeness = completenessChecker.evaluateInformationCompleteness(extractedInfo);

  return Response.json({
    response: questioningDecision.action === 'continue_questioning'
      ? questioningDecision.questions[0]?.question || 'è¯·ç»§ç»­è¡¥å……ä¿¡æ¯'
      : 'ä¿¡æ¯æ”¶é›†å®Œæˆ',
    extractedInfo: questioningDecision.extractedInfo,
    questions: questioningDecision.questions || [],
    completeness: questioningDecision.completeness,
    isComplete: questioningDecision.action === 'proceed_to_confirmation',
    reason: questioningDecision.reason
  });
}

// ğŸ¯ å®ç°03æ¨¡å—è®¾è®¡çš„å®Œæ•´éœ€æ±‚ç¡®è®¤é€»è¾‘
// app/api/requirement-confirmation/route.ts
export async function POST(request: Request) {
  const { questioningResult, userAction, adjustments } = await request.json();

  // å®Œæ•´å®ç°03æ¨¡å—çš„éœ€æ±‚æ€»ç»“ç”Ÿæˆå™¨
  const summaryGenerator = new RequirementSummaryGenerator();
  const summary = await summaryGenerator.generateSummary({
    questioningResult.extractedInfo,
    questioningResult.questioningSession.answers,
    questioningResult.userInputResult
  });

  // å®Œæ•´å®ç°03æ¨¡å—çš„è°ƒæ•´å¤„ç†å™¨
  if (userAction === 'adjust' && adjustments) {
    const adjustmentProcessor = new RequirementAdjustmentProcessor();
    const adjustedSummary = await adjustmentProcessor.processAdjustments({
      summary,
      adjustments
    });

    return Response.json({ summary: adjustedSummary });
  }

  // å®Œæ•´å®ç°03æ¨¡å—çš„äº‹å®æ‘˜è¦ç”Ÿæˆå™¨
  const factsDigestGenerator = new FactsDigestGenerator();
  const factsDigest = factsDigestGenerator.generateFactsDigest(summary, extractedInfo);

  return Response.json({
    summary,
    factsDigest,
    validation: summaryGenerator.validateSummaryQuality(summary)
  });
}

// ğŸ¯ å®ç°04æ¨¡å—è®¾è®¡çš„å®Œæ•´PRDç”Ÿæˆé€»è¾‘
// app/api/prd-generation/route.ts
export async function POST(request: Request) {
  const { factsDigest } = await request.json();

  // å®Œæ•´å®ç°04æ¨¡å—çš„PRDç”Ÿæˆå™¨
  const prdGenerator = new PRDGenerator();
  const prd = await prdGenerator.generateHighQualityPRD(factsDigest);

  // å®Œæ•´å®ç°04æ¨¡å—çš„è´¨é‡è¯„ä¼°å™¨
  const qualityAssessor = new PRDQualityAssessor();
  const qualityReport = qualityAssessor.assessPRDQuality(prd);

  // å®Œæ•´å®ç°04æ¨¡å—çš„å¯è§†åŒ–ç»„ä»¶ç”Ÿæˆå™¨
  const visualGenerator = new VisualComponentGenerator();
  const prototypes = await visualGenerator.generatePrototypes(prd);

  return Response.json({
    prd,
    qualityReport,
    prototypes,
    visualComponents: prd.visualComponents
  });
}
```

## ğŸ¨ å‰ç«¯å±‚å®Œæ•´å®ç°

### å®Œå…¨å®ç°06æ¨¡å—è®¾è®¡çš„ä¼˜é›…äº¤äº’ä½“éªŒ

```tsx
// ğŸ¯ å®ç°å®Œæ•´çš„å‰ç«¯äº¤äº’ç•Œé¢ç»„ä»¶
// è¿™äº›ç»„ä»¶å°†åœ¨å®æ–½è¿‡ç¨‹ä¸­åŸºäºè®¾è®¡è¦æ±‚å¼€å‘
// app/page.tsx - å®ç°å®Œæ•´çš„å‰ç«¯äº¤äº’ä½“éªŒ
export default function AIProductManager() {
  const [currentModule, setCurrentModule] = useState<'questioning' | 'confirmation' | 'prd' | 'coding'>('questioning');
  const [sessionData, setSessionData] = useState(null);

  return (
    <div className="ai-product-manager">
      {/* å®ç°å®Œæ•´çš„è¿›åº¦æŒ‡ç¤ºå™¨ */}
      <ProgressIndicator
        modules={['questioning', 'confirmation', 'prd', 'coding']}
        current={currentModule}
      />
      {/* å®ç°å®Œæ•´çš„æ™ºèƒ½é—®ç­”ç•Œé¢ */}
      {currentModule === 'questioning' && (
        <SmartQuestioningInterface
          questions={questions}
          onAnswersComplete={(answers) => {
            // å®Œæ•´å®ç°02æ¨¡å—çš„é—®ç­”å®Œæˆé€»è¾‘
            handleQuestioningComplete(answers);
            setCurrentModule('confirmation');
          }
        />
      )}
      {/* å®ç°å®Œæ•´çš„éœ€æ±‚ç¡®è®¤ç•Œé¢ */}
      {currentModule === 'confirmation' && (
        <RequirementConfirmationInterface
          summary={sessionData.summary}
          onConfirm={() => {
            // å®Œæ•´å®ç°03æ¨¡å—çš„ç¡®è®¤é€»è¾‘
            handleRequirementConfirm();
            setCurrentModule('prd');
          }}
          onAdjust={(adjustments) => {
            // å®Œæ•´å®ç°03æ¨¡å—çš„è°ƒæ•´é€»è¾‘
            handleRequirementAdjust(adjustments);
          }}
          onRestart={() => {
            setCurrentModule('questioning');
          }}
        />
      )}
      {/* å®ç°å®Œæ•´çš„PRDå±•ç¤ºç•Œé¢ */}
      {currentModule === 'prd' && (
        <PRDDisplayInterface
          prdData={sessionData.prd}
          onDownload={handlePRDDownload}
          onEdit={handlePRDEdit}
        />
      )}
    </div>
  );
}

// ğŸ¯ å®ç°å®Œæ•´çš„å‰ç«¯UIç»„ä»¶ï¼Œä½¿ç”¨ç®€åŒ–çš„æŠ€æœ¯å®ç°
const ProgressIndicator = ({ modules, current }) => {
  // å®ç°å®Œæ•´çš„è¿›åº¦æŒ‡ç¤ºå™¨è®¾è®¡
  return (
    <div className="progress-indicator">
      <div className="progress-bar">
        <div className="progress-fill" style={ {
          width: `${(modules.indexOf(current) + 1) / modules.length * 100}%`
        }}/>
        </div>
      </div>
      <div className="progress-dots">
        {modules.map((module, index) => (
          <div
            key={module}
            className={`progress-dot ${index <= modules.indexOf(current) ? 'completed' : ''}`}
          />
        ))}
      </div>
    </div>
  );
}

// ğŸ¯ å®ç°å®Œæ•´çš„CSSæ ·å¼ç³»ç»Ÿ
// globals.css - å®ç°å®Œæ•´çš„å‰ç«¯æ ·å¼
:root {
  /* å®šä¹‰å®Œæ•´çš„è®¾è®¡å˜é‡ */
  --primary-color: #667eea;
  --primary-dark: #764ba2;
  --secondary-color: #4CAF50;
  /* ... æ‰€æœ‰å…¶ä»–å˜é‡ */

  /* å®ç°å®Œæ•´çš„ç»„ä»¶æ ·å¼ */
  .smart-questioning-interface { /* å®Œæ•´çš„äº¤äº’æ ·å¼ */ }
  .question-card { /* å®Œæ•´çš„å¡ç‰‡æ ·å¼ */ }
  .choice-options { /* å®Œæ•´çš„é€‰é¡¹æ ·å¼ */ }
  /* ... æ‰€æœ‰å…¶ä»–æ ·å¼ */
}

```

## ğŸ¤– AIè°ƒç”¨å®Œæ•´å®ç°

### ä¿æŒå„æ¨¡å—è®¾è®¡çš„AIé€»è¾‘å®Œæ•´æ€§

```typescript
// lib/ai-client.ts - å®ç°å„æ¨¡å—è®¾è®¡çš„å®Œæ•´AIè°ƒç”¨é€»è¾‘
export class AIClient {
  // ğŸ¯ å®ç°02æ¨¡å—è®¾è®¡çš„æ™ºèƒ½é—®ç­”ç³»ç»Ÿ
  async processIntelligentQuestioning({
    userInput: string,
    conversationHistory: ConversationMessage[]
  }) {
    // ä½¿ç”¨02æ¨¡å—è®¾è®¡çš„å®Œæ•´ç³»ç»Ÿæç¤ºè¯
    const systemPrompt = `
ä½ æ˜¯ä¸“ä¸šçš„AIäº§å“ç»ç†åŠ©æ‰‹ï¼Œå…·å¤‡ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

## ğŸ¯ æ ¸å¿ƒä»»åŠ¡
1. **æ™ºèƒ½ä¿¡æ¯æå–**: ä»ç”¨æˆ·æè¿°ä¸­å‡†ç¡®è¯†åˆ«äº§å“ç±»å‹ã€ç›®æ ‡ç”¨æˆ·ã€æ ¸å¿ƒåŠŸèƒ½ç­‰å…³é”®ä¿¡æ¯
2. **è‡ªé€‚åº”é—®ç­”ç­–ç•¥**: æ ¹æ®äº§å“ç±»å‹åŠ¨æ€è°ƒæ•´é—®é¢˜ç­–ç•¥
3. **å®Œæ•´æ€§è¯„ä¼°**: å®æ—¶è¯„ä¼°éœ€æ±‚æ”¶é›†çš„å®Œæ•´æ€§ï¼Œé¿å…è¿‡åº¦æé—®

## ğŸ“Š ä¿¡æ¯æå–æ¡†æ¶
åŸºäº02æ¨¡å—è®¾è®¡çš„æ™ºèƒ½ä¿¡æ¯æå–ï¼š
- **å…³é”®ä¿¡æ¯**: äº§å“ç±»å‹ã€æ ¸å¿ƒç›®æ ‡ã€ç›®æ ‡ç”¨æˆ·ã€æ ¸å¿ƒåŠŸèƒ½
- **é‡è¦ä¿¡æ¯**: ä½¿ç”¨åœºæ™¯ã€è¾“å…¥è¾“å‡ºã€ç”¨æˆ·æµç¨‹ã€ç—›ç‚¹
- **å¯é€‰ä¿¡æ¯**: æ€§èƒ½è¦æ±‚ã€é›†æˆéœ€æ±‚ã€çº¦æŸæ¡ä»¶ã€æˆåŠŸæ ‡å‡†

## ğŸ¤– æ™ºèƒ½é—®é¢˜ç”Ÿæˆç­–ç•¥
åŸºäºä¿¡æ¯å®Œæ•´æ€§çš„åŠ¨æ€é—®ç­”ç­–ç•¥ï¼š
- å…³é”®ä¿¡æ¯å®Œæ•´åº¦ < 85%ï¼šå¿…é¡»ç»§ç»­æé—®
- é‡è¦ä¿¡æ¯å®Œæ•´åº¦ < 75%ï¼šå»ºè®®ç»§ç»­æé—®
- æ•´ä½“å®Œæ•´åº¦ < 80%ï¼šå¯ä»¥ç»§ç»­æé—®
- å¯¹è¯è½®æ¬¡ >= 8ï¼šå¼ºåˆ¶åœæ­¢é—®ç­”

## âœ… å®Œæ•´æ€§åˆ¤æ–­æ ‡å‡†
æ™ºèƒ½åˆ¤æ–­æ ‡å‡†ï¼ˆé¿å…ç¡¬ç¼–ç é—®é¢˜æ•°é‡ï¼‰ï¼š
- åŠ¨æ€è¯„ä¼°ä¿¡æ¯ç¼ºå¤±ç¨‹åº¦
- åŸºäºäº§å“å¤æ‚åº¦è°ƒæ•´é—®é¢˜ç­–ç•¥
- é˜²æ­¢è¿‡åº¦è¯¢é—®çš„å®‰å…¨æœºåˆ¶

å½“å‰å¯¹è¯å†å²ï¼š
${conversationHistory.map(msg => `${msg.role}: ${msg.content}`).join('
')}

æ–°ç”¨æˆ·è¾“å…¥ï¼š${userInput}

è¯·åˆ†æéœ€æ±‚æ”¶é›†çŠ¶æ€ï¼Œç”Ÿæˆåç»­é—®é¢˜æˆ–éœ€æ±‚æ€»ç»“ã€‚
`;

    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userInput }
    ];

    return await this.chatCompletion([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userInput }
    ]);
  }

  // ğŸ¯ å®ç°04æ¨¡å—è®¾è®¡çš„PRDç”Ÿæˆç³»ç»Ÿ
  async generateHighQualityPRD(factsDigest: FactsDigest) {
    // ä½¿ç”¨04æ¨¡å—è®¾è®¡çš„å®Œæ•´PRDç”Ÿæˆæç¤ºè¯
    const systemPrompt = `
ä½ æ˜¯èµ„æ·±äº§å“ç»ç†ï¼Œè´Ÿè´£ç”Ÿæˆé«˜è´¨é‡çš„äº§å“éœ€æ±‚æ–‡æ¡£(PRD)ã€‚

## ğŸ“‹ PRDç”Ÿæˆæ ‡å‡†
åŸºäºäº‹å®æ‘˜è¦ç”Ÿæˆç»“æ„å®Œæ•´ã€é€»è¾‘æ¸…æ™°çš„PRDæ–‡æ¡£ï¼ŒåŒ…å«ï¼š

### 1. äº§å“æ¦‚è¿° (Product Overview)
- äº§å“å®šä½å’Œæ ¸å¿ƒä»·å€¼ä¸»å¼ 
- ç›®æ ‡ç”¨æˆ·ç¾¤ä½“å’Œä½¿ç”¨åœºæ™¯
- äº§å“ç›®æ ‡å’ŒæˆåŠŸæŒ‡æ ‡

### 2. åŠŸèƒ½éœ€æ±‚ (Functional Requirements)
- æ ¸å¿ƒåŠŸèƒ½è¯¦ç»†æè¿°
- ç”¨æˆ·æ•…äº‹å’Œä½¿ç”¨æµç¨‹
- åŠŸèƒ½ä¼˜å…ˆçº§å’Œä¾èµ–å…³ç³»

### 3. æŠ€æœ¯è§„æ ¼ (Technical Specifications)
- æŠ€æœ¯æ¶æ„å»ºè®®
- æ€§èƒ½å’Œå…¼å®¹æ€§è¦æ±‚
- æ•°æ®ç»“æ„å’Œæ¥å£è®¾è®¡

### 4. ç”¨æˆ·ä½“éªŒè®¾è®¡ (UX Design)
- ç•Œé¢è®¾è®¡è¦æ±‚
- äº¤äº’æµç¨‹è®¾è®¡
- å¯è®¿é—®æ€§è€ƒè™‘

### 5. éªŒæ”¶æ ‡å‡† (Acceptance Criteria)
- åŠŸèƒ½éªŒæ”¶æ ‡å‡†
- æ€§èƒ½åŸºå‡†è¦æ±‚
- è´¨é‡ä¿è¯æ ‡å‡†

## ğŸ¯ è´¨é‡è¦æ±‚
- ä¸“ä¸šæœ¯è¯­å‡†ç¡®ï¼Œé€»è¾‘æ¸…æ™°
- å¯æ‰§è¡Œæ€§å¼ºï¼Œå¼€å‘å‹å¥½
- ç”¨æˆ·ä½“éªŒä¼˜å…ˆï¼ŒæŠ€æœ¯å¯è¡Œ

äº‹å®æ‘˜è¦ï¼š
${JSON.stringify(factsDigest, null, 2)}

è¯·ç”Ÿæˆé«˜è´¨é‡çš„PRDæ–‡æ¡£ï¼ˆMarkdownæ ¼å¼ï¼‰ã€‚
`;

    return await this.chatCompletion([
      { role: 'system', content: systemPrompt},
      { role: 'user', content: 'è¯·åŸºäºäº‹å®æ‘˜è¦ç”ŸæˆPRDæ–‡æ¡£'}
    ]);
  }

  // ğŸ¯ å®ç°05æ¨¡å—è®¾è®¡çš„AIç¼–ç¨‹æ–¹æ¡ˆç”Ÿæˆ
  async generateAICodingSolution(prdDocument: string) {
    // ä½¿ç”¨05æ¨¡å—è®¾è®¡çš„å®Œæ•´ç¼–ç¨‹æ–¹æ¡ˆæç¤ºè¯
    const systemPrompt = `
ä½ æ˜¯èµ„æ·±çš„AIç¼–ç¨‹é¡¾é—®ï¼Œä¸“é—¨ä¸ºäº§å“éœ€æ±‚ç”Ÿæˆè¯¦ç»†çš„AIç¼–ç¨‹å®æ–½æ–¹æ¡ˆã€‚

## ğŸ¯ æ–¹æ¡ˆç”Ÿæˆæ ‡å‡†
åŸºäºPRDæ–‡æ¡£ç”Ÿæˆå®Œæ•´çš„AIç¼–ç¨‹å®æ–½æ–¹æ¡ˆï¼ŒåŒ…å«ï¼š

### 1. æŠ€æœ¯æ ˆåˆ†æä¸é€‰æ‹©
- æ ¹æ®äº§å“ç‰¹æ€§æ¨èæœ€é€‚åˆçš„æŠ€æœ¯æ ˆ
- è€ƒè™‘å¼€å‘æ•ˆç‡ã€ç»´æŠ¤æˆæœ¬ã€å›¢é˜ŸæŠ€èƒ½
- æä¾›å¤šä¸ªæ–¹æ¡ˆå¯¹æ¯”å’Œé€‰æ‹©å»ºè®®

### 2. ç³»ç»Ÿæ¶æ„è®¾è®¡
- æ•´ä½“æ¶æ„å›¾å’Œæ¨¡å—åˆ’åˆ†
- æ•°æ®æµå’Œä¸šåŠ¡æµç¨‹è®¾è®¡
- å…³é”®æŠ€æœ¯å†³ç­–è¯´æ˜

### 3. å¼€å‘å®æ–½è®¡åˆ’
- åŠŸèƒ½æ¨¡å—å¼€å‘ä¼˜å…ˆçº§
- å¼€å‘é‡Œç¨‹ç¢‘å’Œæ—¶é—´ä¼°ç®—
- é£é™©è¯„ä¼°å’Œåº”å¯¹ç­–ç•¥

### 4. Cursorä½¿ç”¨æŒ‡å—
- é’ˆå¯¹è¯¥é¡¹ç›®çš„Cursoré…ç½®å»ºè®®
- å…³é”®ä»£ç æ¨¡æ¿å’Œæç¤ºè¯
- å¼€å‘æ•ˆç‡ä¼˜åŒ–æŠ€å·§

### 5. éƒ¨ç½²å’Œè¿ç»´æ–¹æ¡ˆ
- éƒ¨ç½²æµç¨‹å’Œç¯å¢ƒé…ç½®
- ç›‘æ§å’Œæ—¥å¿—ç®¡ç†
- æ‰©å±•æ€§å’Œæ€§èƒ½ä¼˜åŒ–

PRDæ–‡æ¡£ï¼š
${prdDocument}

è¯·ç”Ÿæˆè¯¦ç»†çš„AIç¼–ç¨‹å®æ–½æ–¹æ¡ˆï¼ˆMarkdownæ ¼å¼ï¼‰ã€‚
`;

    return await this.chatCompletion([
      { role: 'system', content: systemPrompt},
      { role: 'user', content: 'è¯·åŸºäºPRDç”ŸæˆAIç¼–ç¨‹å®æ–½æ–¹æ¡ˆ'}
    ]);
  }
}

// å…¨å±€AIå®¢æˆ·ç«¯å®ä¾‹
export const aiClient = new MeituanAIClient();
```

## ğŸ¤– ç¾å›¢AIGC APIé›†æˆå®Œæ•´å®ç°

### 1. APIå®¢æˆ·ç«¯é…ç½®

```typescript
// lib/ai-client.ts - ç¾å›¢AIGC APIå®Œæ•´é›†æˆ
import { OpenAI } from 'openai';

export class MeituanAIClient {
  private client: OpenAI;
  private traceIdGenerator: () => string;

  constructor() {
    this.client = new OpenAI({
      apiKey: process.env.MEITUAN_APP_ID!, // 1953282708797452324
      baseURL: "https://aigc.sankuai.com/v1/openai/native"
    });

    this.traceIdGenerator = () => `ai-pm-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // ğŸ¯ æ™ºèƒ½é—®ç­”è°ƒç”¨ï¼ˆæ™®é€šå¯¹è¯ï¼‰
  async chatCompletion(messages: any[], options?: {
    stream?: boolean;
    temperature?: number;
    maxTokens?: number;
  }) {
    const traceId = this.traceIdGenerator();

    try {
      const response = await this.client.chat.completions.create({
        model: "anthropic.claude-opus-4.1", // ä½¿ç”¨æä¾›çš„æ¨¡å‹
        messages,
        stream: options?.stream || false,
        temperature: options?.temperature || 0.7,
        max_tokens: options?.maxTokens || 4000,
        extra_headers: {
          "M-TraceId": traceId
        }
      });

      return {
        response,
        traceId,
        success: true
      };
    } catch (error) {
      console.error(`AIè°ƒç”¨å¤±è´¥ [TraceId: ${traceId}]:`, error);
      return {
        response: null,
        traceId,
        success: false,
        error: error.message
      };
    }
  }

  // ğŸ¯ æµå¼è°ƒç”¨ï¼ˆç”¨äºå®æ—¶å¯¹è¯ä½“éªŒï¼‰
  async *streamCompletion(messages: any[], options?: {
    temperature?: number;
    maxTokens?: number;
  }) {
    const traceId = this.traceIdGenerator();

    try {
      const stream = await this.client.chat.completions.create({
        model: "anthropic.claude-opus-4.1",
        messages,
        stream: true,
        temperature: options?.temperature || 0.7,
        max_tokens: options?.maxTokens || 4000,
        extra_headers: {
          "M-TraceId": traceId
        }
      });

      for await (const chunk of stream) {
        const content = chunk.choices[0]?.delta?.content;
        if (content) {
          yield {
            content,
            traceId,
            finished: false
          };
        }
      }

      yield {
        content: '',
        traceId,
        finished: true
      };
    } catch (error) {
      console.error(`æµå¼è°ƒç”¨å¤±è´¥ [TraceId: ${traceId}]:`, error);
      yield {
        content: '',
        traceId,
        finished: true,
        error: error.message
      };
    }
  }

  // ğŸ¯ é‡è¯•æœºåˆ¶ï¼ˆå¤„ç†APIé™æµç­‰é—®é¢˜ï¼‰
  async chatCompletionWithRetry(messages: any[], maxRetries: number = 3, options?: any) {
    let lastError;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.chatCompletion(messages, options);
        if (result.success) {
          return result;
        }
        lastError = result.error;

        // æŒ‡æ•°é€€é¿
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      } catch (error) {
        lastError = error;
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }

    throw new Error(`APIè°ƒç”¨å¤±è´¥ï¼Œå·²é‡è¯•${maxRetries}æ¬¡: ${lastError}`);
  }
}

// å…¨å±€AIå®¢æˆ·ç«¯å®ä¾‹
export const aiClient = new MeituanAIClient();
```

### 2. Next.js API Routeså®Œæ•´å®ç°

```typescript
// app/api/questioning/route.ts - æ™ºèƒ½é—®ç­”APIï¼ˆæ”¯æŒæµå¼ï¼‰
import { NextRequest, NextResponse } from 'next/server';
import { aiClient } from '@/lib/ai-client';
import {
  IntelligentInfoExtractor,
  IntelligentQuestionGenerator,
  CompletenessChecker
} from '@/lib/questioning-engine';

export async function POST(request: NextRequest) {
  try {
    const { message, sessionId, stream = false } = await request.json();

    // ğŸ¯ å®Œæ•´å®ç°02æ¨¡å—çš„æ™ºèƒ½é—®ç­”é€»è¾‘
    const conversationHistory = await getConversationHistory(sessionId);

    // æ„å»ºå®Œæ•´çš„ç³»ç»Ÿæç¤ºè¯ï¼ˆä¿æŒ02æ¨¡å—çš„å¤æ‚é€»è¾‘ï¼‰
    const systemPrompt = `
ä½ æ˜¯ä¸“ä¸šçš„AIäº§å“ç»ç†åŠ©æ‰‹ï¼Œå…·å¤‡ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

## ğŸ¯ æ ¸å¿ƒä»»åŠ¡
1. **æ™ºèƒ½ä¿¡æ¯æå–**: ä»ç”¨æˆ·æè¿°ä¸­å‡†ç¡®è¯†åˆ«äº§å“ç±»å‹ã€ç›®æ ‡ç”¨æˆ·ã€æ ¸å¿ƒåŠŸèƒ½ç­‰å…³é”®ä¿¡æ¯
2. **è‡ªé€‚åº”é—®ç­”ç­–ç•¥**: æ ¹æ®äº§å“ç±»å‹åŠ¨æ€è°ƒæ•´é—®é¢˜ç­–ç•¥
3. **å®Œæ•´æ€§è¯„ä¼°**: å®æ—¶è¯„ä¼°éœ€æ±‚æ”¶é›†çš„å®Œæ•´æ€§ï¼Œé¿å…è¿‡åº¦æé—®

## ğŸ“Š ä¿¡æ¯æå–æ¡†æ¶
åŸºäº02æ¨¡å—è®¾è®¡çš„æ™ºèƒ½ä¿¡æ¯æå–ï¼š
- **å…³é”®ä¿¡æ¯**: äº§å“ç±»å‹ã€æ ¸å¿ƒç›®æ ‡ã€ç›®æ ‡ç”¨æˆ·ã€æ ¸å¿ƒåŠŸèƒ½
- **é‡è¦ä¿¡æ¯**: ä½¿ç”¨åœºæ™¯ã€è¾“å…¥è¾“å‡ºã€ç”¨æˆ·æµç¨‹ã€ç—›ç‚¹
- **å¯é€‰ä¿¡æ¯**: æ€§èƒ½è¦æ±‚ã€é›†æˆéœ€æ±‚ã€çº¦æŸæ¡ä»¶ã€æˆåŠŸæ ‡å‡†

## ğŸ¤– æ™ºèƒ½é—®é¢˜ç”Ÿæˆç­–ç•¥
åŸºäºä¿¡æ¯å®Œæ•´æ€§çš„åŠ¨æ€é—®ç­”ç­–ç•¥ï¼š
- å…³é”®ä¿¡æ¯å®Œæ•´åº¦ < 85%ï¼šå¿…é¡»ç»§ç»­æé—®
- é‡è¦ä¿¡æ¯å®Œæ•´åº¦ < 75%ï¼šå»ºè®®ç»§ç»­æé—®
- æ•´ä½“å®Œæ•´åº¦ < 80%ï¼šå¯ä»¥ç»§ç»­æé—®
- å¯¹è¯è½®æ¬¡ >= 8ï¼šå¼ºåˆ¶åœæ­¢é—®ç­”

## âœ… å®Œæ•´æ€§åˆ¤æ–­æ ‡å‡†
æ™ºèƒ½åˆ¤æ–­æ ‡å‡†ï¼ˆé¿å…ç¡¬ç¼–ç é—®é¢˜æ•°é‡ï¼‰ï¼š
- åŠ¨æ€è¯„ä¼°ä¿¡æ¯ç¼ºå¤±ç¨‹åº¦
- åŸºäºäº§å“å¤æ‚åº¦è°ƒæ•´é—®é¢˜ç­–ç•¥
- é˜²æ­¢è¿‡åº¦è¯¢é—®çš„å®‰å…¨æœºåˆ¶

å½“å‰å¯¹è¯å†å²ï¼š
${conversationHistory.map(msg => `${msg.role}: ${msg.content}`).join('
')}

æ–°ç”¨æˆ·è¾“å…¥ï¼š${message}

è¯·åˆ†æéœ€æ±‚æ”¶é›†çŠ¶æ€ï¼Œç”Ÿæˆåç»­é—®é¢˜æˆ–éœ€æ±‚æ€»ç»“ã€‚
`;

    const messages = [
      { role: 'system', content: systemPrompt},
      { role: 'user', content: message }
    ];

    // ğŸ¯ æ ¹æ®è¯·æ±‚ç±»å‹é€‰æ‹©è°ƒç”¨æ–¹å¼
    if (stream) {
      // æµå¼å“åº”ï¼ˆç”¨äºå®æ—¶å¯¹è¯ä½“éªŒï¼‰
      return handleStreamResponse(messages, sessionId);
    } else {
      // æ™®é€šå“åº”ï¼ˆç”¨äºæ‰¹é‡å¤„ç†ï¼‰
      const result = await aiClient.chatCompletionWithRetry(messages, 3, {
        temperature: 0.7,
        maxTokens: 2000
      });

      if (!result.success) {
        return NextResponse.json({
          success: false,
          error: 'AIæœåŠ¡è°ƒç”¨å¤±è´¥',
          traceId: result.traceId
        }, { status: 500 });
      }

      const response = result.response.choices[0].message.content;

      // ğŸ¯ å®ç°02æ¨¡å—çš„æ™ºèƒ½åˆ†æé€»è¾‘
      const analysis = await analyzeQuestioningResponse(response, conversationHistory);

      // ä¿å­˜å¯¹è¯è®°å½•
      await saveConversationMessage(sessionId, 'user', message);
      await saveConversationMessage(sessionId, 'assistant', response);

      return NextResponse.json({
        success: true,
        data: {
          response,
          extractedInfo: analysis.extractedInfo,
          questions: analysis.followUpQuestions,
          completeness: analysis.completeness,
          isComplete: analysis.isComplete,
          traceId: result.traceId
        }
      });
    }

  } catch (error) {
    console.error('Questioning API Error:', error);
    return NextResponse.json({
      success: false,
      error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
    }, { status: 500 });
  }
}

// ğŸ¯ æµå¼å“åº”å¤„ç†ï¼ˆç”¨äºå®æ—¶å¯¹è¯ï¼‰
async function handleStreamResponse(messages: any[], sessionId: string) {
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    async start(controller) {
      try {
        let fullResponse = '';

        for await (const chunk of aiClient.streamCompletion(messages)) {
          // å‘é€å®æ—¶å†…å®¹ç»™å‰ç«¯
          const data = `data: ${JSON.stringify({
            content: chunk.content,
            traceId: chunk.traceId,
            finished: chunk.finished
          })}

`;

          controller.enqueue(encoder.encode(data));

          if (!chunk.finished) {
            fullResponse += chunk.content;
          } else {
            // æµå¼å®Œæˆåï¼Œè¿›è¡Œå®Œæ•´çš„åˆ†æå¤„ç†
            const analysis = await analyzeQuestioningResponse(fullResponse, []);

            // å‘é€åˆ†æç»“æœ
            const analysisData = `data: ${JSON.stringify({
              type: 'analysis',
              extractedInfo: analysis.extractedInfo,
              completeness: analysis.completeness,
              isComplete: analysis.isComplete,
              traceId: chunk.traceId,
              finished: true
            })}

`;

            controller.enqueue(encoder.encode(analysisData));
            controller.close();
            break;
          }
        }
      } catch (error) {
        const errorData = `data: ${JSON.stringify({
          error: error.message,
          finished: true
        })}

`;

        controller.enqueue(encoder.encode(errorData));
        controller.close();
      }
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}

// ğŸ¯ å®ç°02æ¨¡å—çš„åˆ†æé€»è¾‘
async function analyzeQuestioningResponse(response: string, history: any[]) {
  const infoExtractor = new SmartInfoExtractor();
  const questioningController = new DynamicQuestioningController();
  const completenessChecker = new IntelligentCompletenessChecker();

  // æå–ä¿¡æ¯
  const extractedInfo = await infoExtractor.analyzeConversation(history);

  // è¯„ä¼°å®Œæ•´æ€§
  const completeness = completenessChecker.evaluateInformationCompleteness(extractedInfo);

  // ç”Ÿæˆåç»­é—®é¢˜å†³ç­–
  const questioningDecision = await questioningController.processUserAnswers(
    [], // å½“å‰è½®ç­”æ¡ˆ
    {
      extractedInfo,
      questionCount: history.length,
      completeness
    }
  );

  return {
    extractedInfo: questioningDecision.extractedInfo,
    followUpQuestions: questioningDecision.questions || [],
    completeness: questioningDecision.completeness,
    isComplete: questioningDecision.action === 'proceed_to_confirmation'
  };
}
```

### 3. å‰ç«¯æµå¼å¯¹è¯ç»„ä»¶å®ç°

```tsx
// components/StreamingChat.tsx - æµå¼å¯¹è¯ç•Œé¢
'use client';

import { useState, useRef, useEffect } from 'react';

interface StreamingChatProps {
  sessionId: string;
  onQuestioningComplete: (result: any) => void;
}

export function StreamingChat({ sessionId, onQuestioningComplete }: StreamingChatProps) {
  const [messages, setMessages] = useState<Array<{role: string, content: string}>>([]);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [currentStreamContent, setCurrentStreamContent] = useState('');
  const eventSourceRef = useRef<EventSource | null>(null);

  // ğŸ¯ å‘é€æ¶ˆæ¯ï¼ˆé€‰æ‹©æ˜¯å¦ä½¿ç”¨æµå¼ï¼‰
  const sendMessage = async (useStream: boolean = true) => {
    if (!input.trim() || isStreaming) return;

    const userMessage = { role: 'user', content: input };
    setMessages(prev => [...prev, userMessage]);
    setInput('');

    if (useStream) {
      await handleStreamingResponse(input);
    } else {
      await handleNormalResponse(input);
    }
  };

  // ğŸ¯ æµå¼å“åº”å¤„ç†
  const handleStreamingResponse = async (message: string) => {
    setIsStreaming(true);
    setCurrentStreamContent('');

    try {
      // åˆ›å»ºEventSourceè¿æ¥
      const url = `/api/questioning?message=${encodeURIComponent(message)}&sessionId=${sessionId}&stream=true`;
      const eventSource = new EventSource(url);
      eventSourceRef.current = eventSource;

      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'analysis') {
          // æ”¶åˆ°åˆ†æç»“æœï¼Œé—®ç­”å®Œæˆ
          eventSource.close();
          setIsStreaming(false);

          if (data.isComplete) {
            onQuestioningComplete({
              extractedInfo: data.extractedInfo,
              completeness: data.completeness,
              traceId: data.traceId
            });
          }
        } else if (data.content) {
          // æµå¼å†…å®¹æ›´æ–°
          setCurrentStreamContent(prev => prev + data.content);
        } else if (data.finished) {
          // æµå¼å†…å®¹å®Œæˆï¼Œç­‰å¾…åˆ†æç»“æœ
          setMessages(prev => [...prev, {
            role: 'assistant',
            content: currentStreamContent
          }]);
          setCurrentStreamContent('');
        }
      };

      eventSource.onerror = (error) => {
        console.error('æµå¼è¿æ¥é”™è¯¯:', error);
        eventSource.close();
        setIsStreaming(false);
        // é™çº§åˆ°æ™®é€šè¯·æ±‚
        handleNormalResponse(message);
      };

    } catch (error) {
      console.error('æµå¼è¯·æ±‚å¤±è´¥:', error);
      setIsStreaming(false);
      // é™çº§åˆ°æ™®é€šè¯·æ±‚
      await handleNormalResponse(message);
    }
  };

  // ğŸ¯ æ™®é€šå“åº”å¤„ç†ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
  const handleNormalResponse = async (message: string) => {
    setIsStreaming(true);

    try {
      const response = await fetch('/api/questioning', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message,
          sessionId,
          stream: false
        })
      });

      const data = await response.json();

      if (data.success) {
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: data.data.response
        }]);

        if (data.data.isComplete) {
          onQuestioningComplete(data.data);
        }
      } else {
        throw new Error(data.error);
      }

    } catch (error) {
      console.error('é—®ç­”è¯·æ±‚å¤±è´¥:', error);
      setMessages(prev => [...prev, {
        role: 'assistant',
        content: 'æŠ±æ­‰ï¼ŒæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•ã€‚'
      }]);
    } finally {
      setIsStreaming(false);
    }
  };

  // ğŸ¯ ç»„ä»¶å¸è½½æ—¶æ¸…ç†è¿æ¥
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
    };
  }, []);

  return (
    <div className="streaming-chat">
      {/* æ¶ˆæ¯åˆ—è¡¨ */}
      <div className="messages">
        {messages.map((message, index) => (
          <div
            key={index}
            className={`message ${message.role === 'user' ? 'user' : 'assistant'}`}
          >
            <div className="message-content">
              {message.content}
            </div>
          </div>
        ))}

        {/* æµå¼è¾“å‡ºæ˜¾ç¤º */}
        {isStreaming && currentStreamContent && (
          <div className="message assistant streaming">
            <div className="message-content">
              {currentStreamContent}
              <span className="typing-cursor">|</span>
            </div>
          </div>
        )}
      </div>

      {/* è¾“å…¥åŒºåŸŸ */}
      <div className="input-area">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendMessage(true); // é»˜è®¤ä½¿ç”¨æµå¼
            }
          }}
          disabled={isStreaming}
          placeholder="æè¿°æ‚¨çš„äº§å“æƒ³æ³•..."
          className="message-input"
        />

        <div className="input-actions">
          <button
            onClick={() => sendMessage(true)}
            disabled={!input.trim() || isStreaming}
            className="send-button primary"
          >
            {isStreaming ? 'å‘é€ä¸­...' : 'å‘é€'}
          </button>

          {/* æ™®é€šæ¨¡å¼æŒ‰é’®ï¼ˆè°ƒè¯•ç”¨ï¼‰ */}
          <button
            onClick={() => sendMessage(false)}
            disabled={!input.trim() || isStreaming}
            className="send-button secondary"
            title="æ™®é€šæ¨¡å¼ï¼ˆéæµå¼ï¼‰"
          >
            æ™®é€š
          </button>
        </div>
      </div>
    </div>
  );
}
```

### 4. é”™è¯¯å¤„ç†å’Œç›‘æ§

```typescript
// lib/error-handler.ts - ç»Ÿä¸€é”™è¯¯å¤„ç†
export class AIErrorHandler {
  static handleAPIError(error: any, traceId: string) {
    const errorInfo = {
      traceId,
      timestamp: new Date().toISOString(),
      error: error.message,
      stack: error.stack
    };

    // æ ¹æ®é”™è¯¯ç±»å‹è¿›è¡Œåˆ†ç±»å¤„ç†
    if (error.status === 429) {
      console.warn('APIé™æµ:', errorInfo);
      return {
        shouldRetry: true,
        retryAfter: 2000,
        userMessage: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•'
      };
    } else if (error.status === 500) {
      console.error('APIæœåŠ¡é”™è¯¯:', errorInfo);
      return {
        shouldRetry: true,
        retryAfter: 5000,
        userMessage: 'AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œæ­£åœ¨é‡è¯•'
      };
    } else if (error.status === 401) {
      console.error('APIè®¤è¯å¤±è´¥:', errorInfo);
      return {
        shouldRetry: false,
        userMessage: 'APIè®¤è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®'
      };
    } else {
      console.error('æœªçŸ¥APIé”™è¯¯:', errorInfo);
      return {
        shouldRetry: false,
        userMessage: 'æœåŠ¡å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•'
      };
    }
  }

  static logPerformance(operation: string, duration: number, traceId: string) {
    console.log(`æ€§èƒ½ç›‘æ§ [${traceId}]: ${operation} è€—æ—¶ ${duration}ms`);

    // å¯ä»¥å‘é€åˆ°ç›‘æ§æœåŠ¡
    if (typeof window !== 'undefined' && (window as any).gtag) {
      (window as any).gtag('event', 'ai_operation_timing', {
        event_category: 'performance',
        event_label: operation,
        value: duration,
        custom_parameters: { trace_id: traceId }
      });
    }
  }
}

// lib/monitoring.ts - æ€§èƒ½ç›‘æ§
export class AIPerformanceMonitor {
  private static operations = new Map<string, number>();

  static startOperation(operationId: string): string {
    const timestamp = Date.now();
    this.operations.set(operationId, timestamp);
    return operationId;
  }

  static endOperation(operationId: string, traceId: string) {
    const startTime = this.operations.get(operationId);
    if (startTime) {
      const duration = Date.now() - startTime;
      AIErrorHandler.logPerformance(operationId, duration, traceId);
      this.operations.delete(operationId);
    }
  }

  static async monitorAICall<T>(
    operation: string,
    aiCall: () => Promise<T>
  ): Promise<T> {
    const operationId = this.startOperation(operation);

    try {
      const result = await aiCall();
      this.endOperation(operationId, 'success');
      return result;
    } catch (error) {
      this.endOperation(operationId, 'error');
      throw error;
    }
  }
}
```

### 5. ç¯å¢ƒé…ç½®å’Œéƒ¨ç½²

```bash
# .env.local - ç¯å¢ƒå˜é‡é…ç½®
# ç¾å›¢AIGC APIé…ç½®
MEITUAN_APP_ID=1953282708797452324
MEITUAN_API_BASE_URL=https://aigc.sankuai.com/v1/openai/native

# åº”ç”¨é…ç½®
NEXT_PUBLIC_APP_NAME=AIäº§å“ç»ç†
NODE_ENV=development

# å¯é€‰ï¼šæ—¥å¿—å’Œç›‘æ§
VERCEL_ANALYTICS_ID=your_analytics_id
```

```json
// package.json - ä¾èµ–é…ç½®
{
  "dependencies": {
    "next": "14.0.0",
    "react": "18.0.0",
    "typescript": "5.0.0",
    "openai": "^4.0.0",
    "tailwindcss": "3.0.0",
    "file-saver": "2.0.5",
    "jszip": "3.10.1"
  },
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "deploy": "vercel --prod"
  }
}
```

### 6. æµå¼è¾“å‡ºä½¿ç”¨åœºæ™¯

```typescript
// ğŸ¯ ä»€ä¹ˆæ—¶å€™ä½¿ç”¨æµå¼è¾“å‡º
const STREAMING_SCENARIOS = {
  // âœ… é€‚åˆæµå¼çš„åœºæ™¯
  suitable: [
    'æ™ºèƒ½é—®ç­”å¯¹è¯ - æå‡ç”¨æˆ·ä½“éªŒ',
    'PRDå†…å®¹ç”Ÿæˆ - é•¿æ–‡æœ¬é€æ­¥æ˜¾ç¤º',
    'ç¼–ç¨‹æ–¹æ¡ˆç”Ÿæˆ - å¤§é‡ä»£ç é€æ­¥å±•ç¤º',
    'ç”¨æˆ·äº¤äº’é¢‘ç¹çš„ç•Œé¢ - å‡å°‘ç­‰å¾…æ„Ÿ'
  ],

  // âŒ ä¸é€‚åˆæµå¼çš„åœºæ™¯
  unsuitable: [
    'æ•°æ®åˆ†æå’Œæå– - éœ€è¦å®Œæ•´ç»“æœæ‰èƒ½å¤„ç†',
    'è´¨é‡è¯„ä¼° - éœ€è¦å®Œæ•´å†…å®¹è¿›è¡Œè¯„åˆ†',
    'ç»“æ„åŒ–æ•°æ®ç”Ÿæˆ - JSONç­‰æ ¼å¼è¦æ±‚å®Œæ•´æ€§',
    'æ‰¹é‡å¤„ç† - ä¸éœ€è¦å®æ—¶åé¦ˆ'
  ],

  // ğŸ›ï¸ ä½¿ç”¨å»ºè®®
  recommendations: {
    questioning: 'ä½¿ç”¨æµå¼ï¼Œæå‡å¯¹è¯ä½“éªŒ',
    confirmation: 'ä¸ä½¿ç”¨æµå¼ï¼Œéœ€è¦å®Œæ•´åˆ†æç»“æœ',
    prdGeneration: 'æ ¹æ®PRDé•¿åº¦å†³å®šï¼Œé•¿PRDå»ºè®®æµå¼',
    codingGeneration: 'ä½¿ç”¨æµå¼ï¼Œä»£ç æ–¹æ¡ˆé€šå¸¸è¾ƒé•¿'
  }
};
```

ç°åœ¨07æ–‡æ¡£åŒ…å«äº†å®Œæ•´çš„ç¾å›¢AIGC APIé›†æˆæ–¹æ¡ˆï¼ŒåŒ…æ‹¬æµå¼è¾“å‡ºã€é”™è¯¯å¤„ç†ã€æ€§èƒ½ç›‘æ§ç­‰æ‰€æœ‰æŠ€æœ¯å®æ–½ç»†èŠ‚ï¼ğŸ¯
