# ç”¨æˆ·è¾“å…¥æ¨¡å—è®¾è®¡

## æ¨¡å—æ¦‚è¿°

ç”¨æˆ·è¾“å…¥æ¨¡å—æ˜¯æ•´ä¸ªAIäº§å“ç»ç†å·¥å…·çš„å…¥å£ï¼Œè´Ÿè´£æ¥æ”¶å’Œå¤„ç†ç”¨æˆ·çš„éœ€æ±‚æè¿°ï¼Œæ”¯æŒæ–‡æœ¬å’Œå›¾ç‰‡çš„å¤šæ¨¡æ€è¾“å…¥ï¼Œé€šè¿‡AIè¿›è¡ŒåŸºç¡€åˆ†ææ•´åˆï¼Œä¸ºåç»­çš„æ™ºèƒ½é—®ç­”æ¨¡å—æä¾›å®Œæ•´çš„éœ€æ±‚ä¸Šä¸‹æ–‡ã€‚

## æ ¸å¿ƒåŠŸèƒ½

### 1. å¤šæ¨¡æ€è¾“å…¥æ”¯æŒ

#### 1.1 æ–‡æœ¬è¾“å…¥
```typescript
interface TextInput {
  content: string;
  timestamp: Date;
  wordCount: number;
}

const TextInputComponent = () => {
  return (
    <div className="text-input-container">
      <textarea
        placeholder="æè¿°æ‚¨æƒ³è¦å®ç°çš„äº§å“æˆ–åŠŸèƒ½ï¼Œè¶Šè¯¦ç»†è¶Šå¥½..."
        className="requirement-textarea"
        maxLength={2000}
        rows={8}
      />
      <div className="input-helper">
        <span className="word-count">{wordCount}/2000</span>
        <div className="example-prompts">
          <p>ğŸ’¡ ä¾‹å¦‚ï¼š</p>
          <button onClick={fillExample1}>
            "æˆ‘æƒ³åšä¸€ä¸ªæµè§ˆå™¨æ’ä»¶ï¼Œè‡ªåŠ¨æå–ç½‘é¡µé‚®ç®±..."
          </button>
          <button onClick={fillExample2}>
            "éœ€è¦ä¸€ä¸ªå›¢é˜Ÿä»»åŠ¡ç®¡ç†å·¥å…·ï¼Œèƒ½çœ‹åˆ°è¿›åº¦..."
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### 1.2 å›¾ç‰‡è¾“å…¥å¤„ç†
```typescript
interface ImageInput {
  id: string;
  file: File;
  preview: string;
}

// å›¾ç‰‡å¤„ç†ç»„ä»¶
const ImageInputComponent = () => {
  const [images, setImages] = useState<ImageInput[]>([]);

  const handleImageUpload = async (files: FileList) => {
    for (const file of files) {
      if (file.size > 10 * 1024 * 1024) { // 10MBé™åˆ¶
        toast.error('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB');
        continue;
      }

      const imageInput: ImageInput = {
        id: generateId(),
        file,
        preview: URL.createObjectURL(file)
      };

      setImages(prev => [...prev, imageInput]);
    }
  };

  return (
    <div className="image-input-section">
      <div className="upload-area" {...getRootProps()}>
        <input {...getInputProps()} accept="image/*" multiple max={5} />
        <div className="upload-content">
          <FiUpload size={24} />
          <p>æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œï¼Œæˆ–ç‚¹å‡»ä¸Šä¼ </p>
          <p className="upload-hint">æ”¯æŒUIè‰å›¾ã€æµç¨‹å›¾ã€æˆªå›¾ç­‰ï¼ˆæœ€å¤š5å¼ ï¼‰</p>
        </div>
      </div>

      <div className="image-preview-list">
        {images.map(image => (
          <ImagePreview
            key={image.id}
            image={image}
            onRemove={() => removeImage(image.id)}
          />
        ))}
      </div>
    </div>
  );
};
```

### 2. å¤šæ¨¡æ€å†…å®¹åˆ†æ

```typescript
interface MultimodalAnalysis {
  textSummary: string;           // æ–‡æœ¬å†…å®¹æ‘˜è¦
  imageDescriptions: string[];   // å›¾ç‰‡å†…å®¹æè¿°
  extractedText: string[];       // å›¾ç‰‡ä¸­æå–çš„æ–‡å­—
  combinedContext: string;       // æ–‡æœ¬+å›¾ç‰‡çš„ç»¼åˆéœ€æ±‚æè¿°
  confidence: number;            // åˆ†æç½®ä¿¡åº¦
}

class MultimodalAnalyzer {
  async analyzeUserInput(
    textInput: string,
    images: File[]
  ): Promise<MultimodalAnalysis> {

    if (images.length === 0) {
      // çº¯æ–‡æœ¬æƒ…å†µ
      return {
        textSummary: textInput,
        imageDescriptions: [],
        extractedText: [],
        combinedContext: textInput,
        confidence: 1.0
      };
    }

    const prompt = `
      ç”¨æˆ·æƒ³è¦å¼€å‘ä¸€ä¸ªäº§å“ï¼Œæä¾›äº†ä»¥ä¸‹ä¿¡æ¯ï¼š

      æ–‡å­—æè¿°ï¼š${textInput}

      å¦å¤–è¿˜ä¸Šä¼ äº†${images.length}å¼ å›¾ç‰‡ï¼Œè¯·åˆ†æè¿™äº›å›¾ç‰‡å†…å®¹ï¼š
      1. æè¿°å›¾ç‰‡ä¸­çš„å†…å®¹ï¼ˆUIç•Œé¢ã€æµç¨‹å›¾ã€è‰å›¾ç­‰ï¼‰
      2. æå–å›¾ç‰‡ä¸­çš„æ–‡å­—ä¿¡æ¯
      3. ç»“åˆæ–‡å­—æè¿°ï¼Œå½¢æˆå®Œæ•´ç»Ÿä¸€çš„éœ€æ±‚æè¿°

      è¯·è¿”å›JSONæ ¼å¼ï¼š
      {
        "textSummary": "æ–‡å­—æè¿°çš„ç®€æ´æ€»ç»“",
        "imageDescriptions": ["å›¾ç‰‡1çš„è¯¦ç»†æè¿°", "å›¾ç‰‡2çš„è¯¦ç»†æè¿°"],
        "extractedText": ["å›¾ç‰‡1ä¸­çš„æ–‡å­—", "å›¾ç‰‡2ä¸­çš„æ–‡å­—"],
        "combinedContext": "ç»“åˆæ–‡å­—å’Œå›¾ç‰‡çš„å®Œæ•´éœ€æ±‚æè¿°ï¼Œä¿æŒç”¨æˆ·åŸæ„",
        "confidence": 0.95
      }
    `;

    try {
      // è°ƒç”¨å¤šæ¨¡æ€APIè¿›è¡Œåˆ†æ
      const result = await this.multimodalAPI.analyze({
        text: prompt,
        images: images.map(img => this.imageToBase64(img))
      });

      return JSON.parse(result);
    } catch (error) {
      console.error('å¤šæ¨¡æ€åˆ†æå¤±è´¥:', error);
      // é™çº§å¤„ç†ï¼šåªè¿”å›æ–‡æœ¬å†…å®¹
      return {
        textSummary: textInput,
        imageDescriptions: images.map((_, index) => `å›¾ç‰‡${index + 1}ï¼ˆåˆ†æå¤±è´¥ï¼‰`),
        extractedText: [],
        combinedContext: textInput + '

æ³¨ï¼šå›¾ç‰‡åˆ†æå¤±è´¥ï¼Œè¯·åœ¨åç»­é—®ç­”ä¸­è¡¥å……ç›¸å…³ä¿¡æ¯ã€‚',
        confidence: 0.5
      };
    }
  }

  private imageToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }
}
```

### 3. åŸºç¡€è¾“å…¥éªŒè¯

```typescript
interface BasicValidation {
  isValid: boolean;
  hasContent: boolean;
  wordCount: number;
  issues: string[];
}

class BasicInputValidator {
  validate(textInput: string, images: File[]): BasicValidation {
    const issues: string[] = [];

    // å†…å®¹æ£€æŸ¥
    const hasTextContent = textInput && textInput.trim().length >= 10;
    const hasImageContent = images && images.length > 0;

    if (!hasTextContent && !hasImageContent) {
      issues.push('è¯·æè¿°æ‚¨çš„äº§å“æƒ³æ³•æˆ–ä¸Šä¼ ç›¸å…³å›¾ç‰‡');
    }

    // æ–‡æœ¬é•¿åº¦æ£€æŸ¥
    if (textInput && textInput.length > 2000) {
      issues.push('æ–‡å­—æè¿°è¯·æ§åˆ¶åœ¨2000å­—ä»¥å†…');
    }

    if (textInput && textInput.trim().length < 10 && images.length === 0) {
      issues.push('æ–‡å­—æè¿°è¿‡çŸ­ï¼Œè¯·æä¾›æ›´å¤šç»†èŠ‚æˆ–ä¸Šä¼ ç›¸å…³å›¾ç‰‡');
    }

    // å›¾ç‰‡æ£€æŸ¥
    if (images.length > 5) {
      issues.push('æœ€å¤šä¸Šä¼ 5å¼ å›¾ç‰‡');
    }

    for (const image of images) {
      if (image.size > 10 * 1024 * 1024) {
        issues.push(`å›¾ç‰‡ ${image.name} è¿‡å¤§ï¼Œè¯·æ§åˆ¶åœ¨10MBä»¥å†…`);
      }

      if (!image.type.startsWith('image/')) {
        issues.push(`${image.name} ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶`);
      }
    }

    return {
      isValid: issues.length === 0,
      hasContent: hasTextContent || hasImageContent,
      wordCount: textInput?.length || 0,
      issues
    };
  }
}
```

## ç”¨æˆ·ç•Œé¢è®¾è®¡

### ä¸»è¾“å…¥ç•Œé¢
```tsx
const UserInputModule = () => {
  const [textInput, setTextInput] = useState('');
  const [images, setImages] = useState<File[]>([]);
  const [analysis, setAnalysis] = useState<MultimodalAnalysis | null>(null);
  const [validation, setValidation] = useState<BasicValidation | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const handleInputChange = async (text: string, imageFiles: File[]) => {
    setTextInput(text);
    setImages(imageFiles);

    // åŸºç¡€éªŒè¯
    const basicValidation = validator.validate(text, imageFiles);
    setValidation(basicValidation);

    // å¦‚æœæœ‰æ•ˆä¸”æœ‰å†…å®¹ï¼Œè¿›è¡Œå¤šæ¨¡æ€åˆ†æ
    if (basicValidation.isValid && basicValidation.hasContent) {
      setIsAnalyzing(true);
      try {
        const analysisResult = await multimodalAnalyzer.analyzeUserInput(text, imageFiles);
        setAnalysis(analysisResult);
      } catch (error) {
        console.error('å¤šæ¨¡æ€åˆ†æå¤±è´¥:', error);
      } finally {
        setIsAnalyzing(false);
      }
    } else {
      setAnalysis(null);
    }
  };

  const handleSubmit = async () => {
    if (!validation?.isValid || !analysis) return;

    const result: UserInputResult = {
      originalInput: {
        text: textInput,
        images: images,
        timestamp: new Date()
      },
      multimodalAnalysis: analysis,
      validation: validation
    };

    // è¿›å…¥æ™ºèƒ½é—®ç­”æ¨¡å—
    onNextStep(result);
  };

  return (
    <div className="user-input-module">
      <div className="input-header">
        <h1>ğŸ¯ æè¿°æ‚¨çš„äº§å“æƒ³æ³•</h1>
        <p>è¯¦ç»†æè¿°æ‚¨æƒ³è¦å®ç°çš„äº§å“åŠŸèƒ½ï¼Œä¹Ÿå¯ä»¥ä¸Šä¼ ç›¸å…³çš„ç•Œé¢è‰å›¾ã€æµç¨‹å›¾ç­‰</p>
      </div>

      {/* æ–‡æœ¬è¾“å…¥åŒºåŸŸ */}
      <div className="text-input-section">
        <textarea
          value={textInput}
          onChange={(e) => handleInputChange(e.target.value, images)}
          placeholder="æè¿°æ‚¨æƒ³è¦å®ç°çš„äº§å“æˆ–åŠŸèƒ½ï¼Œä¾‹å¦‚ï¼šæˆ‘æƒ³åšä¸€ä¸ªæµè§ˆå™¨æ’ä»¶ï¼Œå¯ä»¥è‡ªåŠ¨æå–ç½‘é¡µä¸­çš„é‚®ç®±åœ°å€..."
          className="input-textarea"
          rows={6}
          maxLength={2000}
        />
        <div className="input-meta">
          <span className="word-count">{textInput.length}/2000</span>
        </div>
      </div>

      {/* å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ */}
      <div className="image-input-section">
        <h3>ğŸ“ ä¸Šä¼ ç›¸å…³å›¾ç‰‡ï¼ˆå¯é€‰ï¼‰</h3>
        <p className="hint">UIè‰å›¾ã€æµç¨‹å›¾ã€å‚è€ƒæˆªå›¾ç­‰ï¼Œæœ‰åŠ©äºæ›´å¥½åœ°ç†è§£æ‚¨çš„éœ€æ±‚</p>

        <input
          type="file"
          accept="image/*"
          multiple
          onChange={(e) => {
            const files = Array.from(e.target.files || []);
            handleInputChange(textInput, files);
          }}
          className="image-input"
        />

        {images.length > 0 && (
          <div className="image-preview">
            {images.map((image, index) => (
              <div key={index} className="image-item">
                <img
                  src={URL.createObjectURL(image)}
                  alt={`ä¸Šä¼ å›¾ç‰‡${index + 1}`}
                  className="preview-image"
                />
                <span className="image-name">{image.name}</span>
                <button
                  onClick={() => {
                    const newImages = images.filter((_, i) => i !== index);
                    handleInputChange(textInput, newImages);
                  }}
                  className="remove-image"
                >
                  Ã—
                </button>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* å¤šæ¨¡æ€åˆ†æçŠ¶æ€ */}
      {isAnalyzing && (
        <div className="analysis-loading">
          <div className="loading-spinner"></div>
          <p>ğŸ” æ­£åœ¨åˆ†ææ‚¨çš„è¾“å…¥å†…å®¹...</p>
        </div>
      )}

      {/* åˆ†æç»“æœé¢„è§ˆ */}
      {analysis && (
        <div className="analysis-preview">
          <h4>ğŸ“‹ éœ€æ±‚ç†è§£é¢„è§ˆ</h4>
          <div className="combined-context">
            <p>{analysis.combinedContext}</p>
            <span className="confidence">ç½®ä¿¡åº¦: {(analysis.confidence * 100).toFixed(0)}%</span>
          </div>

          {analysis.imageDescriptions.length > 0 && (
            <details className="image-analysis">
              <summary>æŸ¥çœ‹å›¾ç‰‡åˆ†æè¯¦æƒ…</summary>
              <div className="image-details">
                {analysis.imageDescriptions.map((desc, index) => (
                  <div key={index} className="image-detail">
                    <strong>å›¾ç‰‡{index + 1}:</strong> {desc}
                    {analysis.extractedText[index] && (
                      <div className="extracted-text">
                        <em>æå–çš„æ–‡å­—:</em> {analysis.extractedText[index]}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </details>
          )}
        </div>
      )}

      {/* éªŒè¯åé¦ˆ */}
      {validation && !validation.isValid && (
        <div className="validation-feedback">
          {validation.issues.map((issue, index) => (
            <p key={index} className="validation-issue">âš ï¸ {issue}</p>
          ))}
        </div>
      )}

      {/* æäº¤æŒ‰é’® */}
      <div className="submit-section">
        <button
          onClick={handleSubmit}
          disabled={!validation?.isValid || isAnalyzing || !analysis}
          className="next-step-button"
        >
          {isAnalyzing ? 'åˆ†æä¸­...' : 'å¼€å§‹æ™ºèƒ½é—®ç­” â†’'}
        </button>

        {analysis && analysis.confidence < 0.7 && (
          <p className="low-confidence-hint">
            ğŸ’¡ å†…å®¹åˆ†æç½®ä¿¡åº¦è¾ƒä½ï¼Œå»ºè®®è¡¥å……æ›´è¯¦ç»†çš„æè¿°
          </p>
        )}
      </div>
    </div>
  );
};
```

### è¾“å‡ºæ¥å£

```typescript
interface UserInputResult {
  // åŸå§‹è¾“å…¥å†…å®¹
  originalInput: {
    text: string;
    images: File[];
    timestamp: Date;
  };

  // å¤šæ¨¡æ€åˆ†æç»“æœ
  multimodalAnalysis: {
    textSummary: string;           // æ–‡æœ¬æ‘˜è¦
    imageDescriptions: string[];   // å›¾ç‰‡æè¿°
    extractedText: string[];       // å›¾ç‰‡ä¸­çš„æ–‡å­—
    combinedContext: string;       // ç»¼åˆéœ€æ±‚æè¿°
    confidence: number;            // åˆ†æç½®ä¿¡åº¦
  };

  // éªŒè¯ç»“æœ
  validation: {
    isValid: boolean;
    hasContent: boolean;
    wordCount: number;
    issues: string[];
  };
}
```

## å…³é”®ç‰¹æ€§

### âœ… å¤šæ¨¡æ€è¾“å…¥æ”¯æŒ
- æ–‡æœ¬è¾“å…¥ï¼šæ”¯æŒè¯¦ç»†éœ€æ±‚æè¿°ï¼ˆæœ€å¤š2000å­—ï¼‰
- å›¾ç‰‡è¾“å…¥ï¼šUIè‰å›¾ã€æµç¨‹å›¾ã€äº§å“æˆªå›¾ç­‰ï¼ˆæœ€å¤š5å¼ ï¼Œæ¯å¼ æœ€å¤š10MBï¼‰

### âœ… æ™ºèƒ½å†…å®¹æ•´åˆ
- åˆ©ç”¨å¤šæ¨¡æ€AIåˆ†ææ–‡æœ¬å’Œå›¾ç‰‡å†…å®¹
- æå–å›¾ç‰‡ä¸­çš„æ–‡å­—ä¿¡æ¯
- ç”Ÿæˆç»Ÿä¸€çš„éœ€æ±‚ä¸Šä¸‹æ–‡æè¿°

### âœ… åŸºç¡€è´¨é‡ä¿è¯
- è¾“å…¥å†…å®¹éªŒè¯ï¼ˆé•¿åº¦ã€æ ¼å¼ã€æ–‡ä»¶å¤§å°ï¼‰
- å¤šæ¨¡æ€åˆ†æç½®ä¿¡åº¦è¯„ä¼°
- å‹å¥½çš„é”™è¯¯æç¤ºå’Œå»ºè®®

### âœ… ç”¨æˆ·ä½“éªŒå‹å¥½
- å®æ—¶é¢„è§ˆåˆ†æç»“æœ
- ç›´è§‚çš„å›¾ç‰‡ä¸Šä¼ å’Œç®¡ç†
- æ¸…æ™°çš„è¿›åº¦åé¦ˆ

## ä¸åç»­æ¨¡å—çš„æ¥å£

ç”¨æˆ·è¾“å…¥æ¨¡å—å¤„ç†å®Œæˆåï¼Œå°† `UserInputResult` ä¼ é€’ç»™**æ™ºèƒ½é—®ç­”æ¨¡å—ï¼ˆ02æ¨¡å—ï¼‰**ï¼Œæä¾›ï¼š

1. **åŸå§‹è¾“å…¥**ï¼šä¿ç•™ç”¨æˆ·çš„åŸå§‹æ–‡æœ¬å’Œå›¾ç‰‡ï¼Œä¾›å‚è€ƒå’Œå›æº¯
2. **å¤šæ¨¡æ€åˆ†æ**ï¼šç»¼åˆçš„éœ€æ±‚ä¸Šä¸‹æ–‡ï¼Œå‡å°‘02æ¨¡å—çš„é‡å¤åˆ†æå·¥ä½œ
3. **è´¨é‡ä¿¡æ¯**ï¼šè¾“å…¥è´¨é‡å’Œåˆ†æç½®ä¿¡åº¦ï¼Œå¸®åŠ©02æ¨¡å—è°ƒæ•´é—®ç­”ç­–ç•¥

**èŒè´£è¾¹ç•Œ**ï¼š
- **01æ¨¡å—**ï¼šè´Ÿè´£è¾“å…¥æ”¶é›†å’ŒåŸºç¡€æ•´åˆï¼Œä¸åšæ™ºèƒ½æ¨ç†å’Œäº§å“åˆ†æ
- **02æ¨¡å—**ï¼šåŸºäº01æ¨¡å—çš„è¾“å‡ºè¿›è¡Œæ·±åº¦çš„éœ€æ±‚åˆ†æå’Œæ™ºèƒ½é—®ç­”
