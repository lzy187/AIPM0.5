# 需求确认模块设计

## 模块概述

需求确认模块承担双重职责：
1. **用户确认界面**：将智能问答的复杂输出转换为用户友好的需求总结，供用户确认和调整
2. **04模块输入准备**：基于用户确认结果和原始数据，生成PRD模块需要的详细完整输入

## 核心设计原则

### ✅ **双重输出分离**
- **用户界面**：简洁明了，避免技术术语，专注核心功能确认
- **04模块输入**：详细完整，包含PRD生成所需的所有技术信息

### ✅ **用户友好的确认体验**
- 清晰展示理解结果，语言简洁易懂
- 支持快速修正和调整功能
- 一键确认或重新澄清需求

### ✅ **承担数据转换职责**
- 为04模块减轻数据处理压力
- 将用户确认结果扩展为完整的技术规格
- 确保04模块专注PRD生成和流式输出

## 🔄 处理流程

### 1. 接收智能问答结果

```typescript
interface SmartQuestioningResult {
  // 核心提取信息
  extractedInfo: ExtractedInfo;

  // 问答会话数据
  questioningSession: {
    questions: Question[];
    answers: Answer[];
    totalRounds: number;
    duration: number;
    completionReason: string;
  };

  // 信息完整性评估
  completeness: {
    critical: number;      // 关键信息完整度 (0-1)
    important: number;     // 重要信息完整度 (0-1)
    optional: number;      // 可选信息完整度 (0-1)
    overall: number;       // 整体完整度 (0-1)
  };

  // 用户输入原始数据
  userInputResult: UserInputResult;

  // 质量验证
  validation: {
    extractionConfidence: number;  // 信息提取置信度
    questioningQuality: number;    // 问答质量评分
    readyForConfirmation: boolean; // 是否准备好进入确认阶段
  };
}
```

### 2. 生成需求理解总结

```typescript
interface RequirementSummary {
  projectName: string;
  coreGoal: string;
  targetUsers: string;
  mainFeatures: Feature[];
  technicalLevel: 'simple' | 'moderate' | 'complex';
  keyConstraints?: string[];
  userScope: string;
}

interface Feature {
  name: string;
  description: string;
  essential: boolean;
  source: 'user_input' | 'ai_inferred' | 'user_confirmed';
}
```

### 3. 需求总结生成器

```typescript
class RequirementSummaryGenerator {
  async generateSummary(
    extractedInfo: ExtractedInfo,
    answers: Answer[],
    userInputResult: UserInputResult
  ): Promise<RequirementSummary> {
    const prompt = `
      基于用户需求和问答结果，生成准确简洁的需求理解总结：

      原始需求：${userInputResult.originalInput.text}
      提取信息：${JSON.stringify(extractedInfo)}
      问答结果：${JSON.stringify(answers)}

      请生成JSON格式的需求总结：
      {
        "projectName": "项目名称（简洁有意义）",
        "coreGoal": "核心目标（一句话，20字内，用用户语言表达）",
        "targetUsers": "目标用户群体",
        "mainFeatures": [
          {
            "name": "功能名称",
            "description": "功能说明（用户能理解的语言）",
            "essential": true/false
          }
        ],
        "technicalLevel": "simple/moderate/complex",
        "keyConstraints": ["关键约束条件"],
        "userScope": "personal/small_team/public"
      }

      要求：
      1. 功能数量控制在3-5个，避免过度工程化
      2. 语言简洁明了，避免技术术语
      3. 突出核心功能，次要功能标记为非必需
      4. 基于用户的实际表达，不要过度推断
    `

    return await claudeAPI.generateStructuredSummary(prompt)
  }

  validateSummaryQuality(summary: RequirementSummary): ValidationResult {
    const issues: string[] = []
    let score = 1.0

    // 功能过多检查
    if (summary.mainFeatures.length > 6) {
      issues.push('功能较多，建议简化为核心功能')
      score -= 0.2
    }

    // 复杂度与功能不匹配检查
    const essentialCount = summary.mainFeatures.filter(f => f.essential).length
    if (summary.technicalLevel === 'simple' && essentialCount > 4) {
      issues.push('功能数量与简单复杂度不匹配')
      score -= 0.3
    }

    // 目标清晰度检查
    if (summary.coreGoal.length > 30 || summary.coreGoal.includes('系统') || summary.coreGoal.includes('平台')) {
      issues.push('核心目标表述可以更具体')
      score -= 0.1
    }

    return {
      isValid: score >= 0.7,
      score,
      issues,
      suggestions: this.generateImprovementSuggestions(summary, issues)
    }
  }

  private generateImprovementSuggestions(summary: RequirementSummary, issues: string[]): string[] {
    const suggestions: string[] = []

    if (issues.includes('功能较多，建议简化为核心功能')) {
      suggestions.push('考虑将次要功能标记为可选，专注核心价值')
    }

    if (issues.includes('核心目标表述可以更具体')) {
      suggestions.push('用更具体的动词描述用户想要达成的目标')
    }

    return suggestions
  }
}
```

## 🎨 确认界面设计

### 需求确认界面组件

```tsx
const RequirementConfirmationInterface = ({
  summary,
  onConfirm,
  onAdjust,
  onRestart
}: {
  summary: RequirementSummary,
  onConfirm: () => void,
  onAdjust: (adjustments: AdjustmentRequest[]) => void,
  onRestart: () => void
}) => {
  const [selectedAdjustments, setSelectedAdjustments] = useState<AdjustmentRequest[]>([])

  return (
    <div className="requirement-confirmation-interface">
      <div className="confirmation-header">
        <h2>🎯 请确认我们对您需求的理解</h2>
        <p className="sub-text">确认后我们将生成详细的产品需求文档</p>
      </div>

      <div className="summary-card">
        <div className="summary-section">
          <div className="goal-section">
            <h3>核心目标</h3>
            <p className="goal-text">{summary.coreGoal}</p>
            <button
              className="adjust-button"
              onClick={() => toggleAdjustment('goal', summary.coreGoal)}
            >
              修改
            </button>
          </div>

          <div className="users-section">
            <h3>目标用户</h3>
            <p>{summary.targetUsers}</p>
            <button
              className="adjust-button"
              onClick={() => toggleAdjustment('users', summary.targetUsers)}
            >
              修改
            </button>
          </div>

          <div className="complexity-section">
            <h3>技术复杂度</h3>
            <span className={`complexity-badge ${summary.technicalLevel}`}>
              {getComplexityLabel(summary.technicalLevel)}
            </span>
          </div>
        </div>

        <div className="features-section">
          <h3>主要功能</h3>
          {summary.mainFeatures.map((feature, index) => (
            <div key={index} className="feature-item">
              <div className="feature-content">
                <span className="feature-name">{feature.name}</span>
                <span className="feature-desc">{feature.description}</span>
                {feature.essential && <span className="essential-badge">核心</span>}
              </div>
              <div className="feature-actions">
                <button onClick={() => toggleAdjustment('modify_feature', feature, index)}>
                  修改
                </button>
                <button onClick={() => toggleAdjustment('remove_feature', feature, index)}>
                  删除
                </button>
              </div>
            </div>
          ))}

          <button
            className="add-feature-button"
            onClick={() => toggleAdjustment('add_feature')}
          >
            + 添加功能
          </button>
        </div>
      </div>

      {/* 调整面板 */}
      {selectedAdjustments.length > 0 && (
        <div className="adjustment-panel">
          <h4>需要调整的内容</h4>
          {selectedAdjustments.map((adj, index) => (
            <AdjustmentItem
              key={index}
              adjustment={adj}
              onUpdate={(updated) => updateAdjustment(index, updated)}
              onRemove={() => removeAdjustment(index)}
            />
          ))}
          <div className="adjustment-actions">
            <button onClick={() => onAdjust(selectedAdjustments)}>
              应用调整
            </button>
            <button onClick={() => setSelectedAdjustments([])}>
              取消
            </button>
          </div>
        </div>
      )}

      <div className="confirmation-actions">
        <button onClick={onConfirm} className="primary-confirm-btn">
          ✅ 理解准确，生成PRD
        </button>
        <button onClick={() => setShowAdjustmentHelp(true)} className="secondary-adjust-btn">
          🔧 需要微调
        </button>
        <button onClick={onRestart} className="restart-btn">
          🔄 重新开始问答
        </button>
      </div>
    </div>
  )
}

// 调整项组件
const AdjustmentItem = ({ adjustment, onUpdate, onRemove }) => {
  const [editValue, setEditValue] = useState(adjustment.currentValue)

  return (
    <div className="adjustment-item">
      <div className="adjustment-header">
        <span className="adjustment-type">{getAdjustmentTypeLabel(adjustment.type)}</span>
        <button onClick={onRemove} className="remove-adjustment">×</button>
      </div>

      <div className="adjustment-content">
        {adjustment.type === 'modify_text' && (
          <textarea
            value={editValue}
            onChange={(e) => setEditValue(e.target.value)}
            placeholder="输入修改后的内容"
          />
        )}

        {adjustment.type === 'add_feature' && (
          <div className="add-feature-form">
            <input
              placeholder="功能名称"
              onChange={(e) => onUpdate({...adjustment, name: e.target.value})}
            />
            <textarea
              placeholder="功能描述"
              onChange={(e) => onUpdate({...adjustment, description: e.target.value})}
            />
            <label>
              <input type="checkbox" />
              核心功能
            </label>
          </div>
        )}
      </div>

      <button
        onClick={() => onUpdate({...adjustment, newValue: editValue})}
        className="apply-adjustment"
      >
        应用
      </button>
    </div>
  )
}

// 工具函数
const getComplexityLabel = (level: string): string => {
  const labels = {
    'simple': '简单',
    'moderate': '中等',
    'complex': '复杂'
  }
  return labels[level] || level
}

const getAdjustmentTypeLabel = (type: string): string => {
  const labels = {
    'goal': '修改目标',
    'users': '修改用户',
    'modify_feature': '修改功能',
    'add_feature': '添加功能',
    'remove_feature': '删除功能'
  }
  return labels[type] || type
}
```

### 调整请求处理

```typescript
interface AdjustmentRequest {
  type: 'goal' | 'users' | 'modify_feature' | 'add_feature' | 'remove_feature';
  currentValue?: any;
  newValue?: any;
  featureIndex?: number;
}

class RequirementAdjustmentProcessor {
  async processAdjustments(
    summary: RequirementSummary,
    adjustments: AdjustmentRequest[]
  ): Promise<RequirementSummary> {
    let adjustedSummary = { ...summary }

    for (const adjustment of adjustments) {
      switch (adjustment.type) {
        case 'goal':
          adjustedSummary.coreGoal = adjustment.newValue
          break

        case 'users':
          adjustedSummary.targetUsers = adjustment.newValue
          break

        case 'modify_feature':
          if (adjustment.featureIndex !== undefined) {
            adjustedSummary.mainFeatures[adjustment.featureIndex] = {
              ...adjustedSummary.mainFeatures[adjustment.featureIndex],
              ...adjustment.newValue
            }
          }
          break

        case 'add_feature':
          adjustedSummary.mainFeatures.push({
            name: adjustment.newValue.name,
            description: adjustment.newValue.description,
            essential: adjustment.newValue.essential || false,
            source: 'user_confirmed'
          })
          break

        case 'remove_feature':
          if (adjustment.featureIndex !== undefined) {
            adjustedSummary.mainFeatures.splice(adjustment.featureIndex, 1)
          }
          break
      }
    }

    // 重新验证调整后的总结
    const validation = this.summaryGenerator.validateSummaryQuality(adjustedSummary)
    if (!validation.isValid) {
      throw new Error(`调整后的需求总结存在问题：${validation.issues.join(', ')}`)
    }

    return adjustedSummary
  }
}
```

## 📊 双重输出结果

### 输出1：用户确认界面展示

```typescript
// 用户确认界面的简洁需求总结
interface RequirementSummary {
  projectName: string;           // "邮箱提取插件"
  coreGoal: string;             // "自动提取网页邮箱，提高效率"
  targetUsers: string;          // "个人用户"
  mainFeatures: Feature[];      // 3-5个核心功能，简洁展示
  technicalLevel: 'simple' | 'moderate' | 'complex';
  keyConstraints?: string[];    // 关键约束（如有）
  userScope: 'personal' | 'small_team' | 'public';
}

interface Feature {
  name: string;                 // "自动识别邮箱"
  description: string;          // "扫描网页中的邮箱地址"
  essential: boolean;           // 是否为核心功能
  source: 'user_input' | 'ai_inferred' | 'user_confirmed';
}
```

### 输出2：传递给04模块的详细事实摘要

```typescript
// PRD生成器需要的完整技术输入（匹配04模块接口）
interface FactsDigest {
  productDefinition: {
    type: string;                     // "browser_extension"
    coreGoal: string;                // "自动提取网页中的邮箱地址，提高收集效率"
    targetUsers: string;             // "经常需要收集客户邮箱的个人用户"
    userScope: string;               // "personal"
  };

  functionalRequirements: {
    coreFeatures: string[];          // ["自动识别网页邮箱", "一键提取功能"]
    useScenarios: string[];          // ["收集客户邮箱", "批量联系人整理"]
    userJourney: string;             // "打开网页 → 点击插件图标 → 自动扫描识别..."
  };

  constraints: {
    technicalLevel: string;          // "simple"
    keyLimitations: string[];        // ["浏览器权限限制", "跨域访问限制"]
    platformPreference?: string;     // 平台偏好（可选）
  };

  contextualInfo: {
    painPoints: string[];            // ["手动复制粘贴很麻烦"]
    currentSolutions: string[];      // ["手动查找和复制邮箱地址"]
    businessValue?: string;          // "提高工作效率，减少重复劳动"
    performanceRequirements?: string; // "快速响应，内存占用<10MB"
    dataHandling?: string;           // "保存提取结果到本地Excel或CSV文件"
    securityConsiderations?: string[]; // ["不收集用户数据", "本地处理"]
  };
}

```

### 事实摘要生成器

```typescript
class FactsDigestGenerator {
  generateFactsDigest(
    confirmedSummary: RequirementSummary,
    originalExtractedInfo: ExtractedInfo,
    questioningSession: QuestioningSession
  ): FactsDigest {
    return {
      productDefinition: {
        type: this.inferProductType(confirmedSummary, originalExtractedInfo),
        coreGoal: confirmedSummary.coreGoal,
        targetUsers: confirmedSummary.targetUsers,
        userScope: confirmedSummary.userScope
      },

      functionalRequirements: {
        coreFeatures: confirmedSummary.mainFeatures.map(f => f.name),
        useScenarios: [originalExtractedInfo.useScenario].filter(Boolean),
        userJourney: originalExtractedInfo.userJourney || this.constructUserJourney(confirmedSummary)
      },

      constraints: {
        technicalLevel: confirmedSummary.technicalLevel,
        keyLimitations: confirmedSummary.keyConstraints || [],
        platformPreference: this.inferPlatformPreference(originalExtractedInfo.technicalHints)
      },

      contextualInfo: {
        painPoints: [originalExtractedInfo.painPoint].filter(Boolean),
        currentSolutions: [originalExtractedInfo.currentSolution].filter(Boolean),
        businessValue: this.inferBusinessValue(originalExtractedInfo.painPoint),
        performanceRequirements: originalExtractedInfo.performanceRequirements,
        dataHandling: originalExtractedInfo.dataHandling,
        securityConsiderations: this.inferSecurityRequirements(confirmedSummary.userScope)
      }
    };
  }

  private inferPlatformPreference(technicalHints: string[]): string {
    if (!technicalHints || technicalHints.length === 0) return "跨平台";

    const hints = technicalHints.join(' ').toLowerCase();

    if (hints.includes('chrome') || hints.includes('firefox') || hints.includes('extension')) {
      return "浏览器插件";
    }
    if (hints.includes('web') || hints.includes('html') || hints.includes('javascript')) {
      return "Web应用";
    }
    if (hints.includes('desktop') || hints.includes('electron')) {
      return "桌面应用";
    }
    if (hints.includes('mobile') || hints.includes('app')) {
      return "移动应用";
    }

    return "跨平台";
  }

  private inferBusinessValue(painPoint: string): string {
    if (!painPoint) return "提升用户体验和工作效率";

    if (painPoint.includes('手动') || painPoint.includes('麻烦')) {
      return "自动化处理，大幅提高工作效率，减少重复劳动";
    }
    if (painPoint.includes('分散') || painPoint.includes('找不到')) {
      return "统一管理，便于查找和使用，提升组织效率";
    }
    if (painPoint.includes('协作') || painPoint.includes('沟通')) {
      return "改善协作体验，提升团队工作效率";
    }

    return "解决用户痛点，提升使用体验和工作效率";
  }

  private constructUserJourney(summary: RequirementSummary): string {
    // 基于功能构建基本用户流程
    const steps = summary.mainFeatures
      .filter(f => f.essential)
      .map(f => this.featureToStep(f.name))
      .join(' → ');

    return steps || '打开工具 → 执行操作 → 获得结果';
  }

  private featureToStep(featureName: string): string {
    const stepMappings = {
      '识别': '智能识别',
      '提取': '一键提取',
      '保存': '保存结果',
      '导出': '导出数据',
      '管理': '管理内容',
      '分析': '分析处理'
    };

    for (const [key, step] of Object.entries(stepMappings)) {
      if (featureName.includes(key)) {
        return step;
      }
    }

    return featureName;
  }

  private inferSecurityRequirements(userScope: string): string[] {
    const baseRequirements = ["数据安全保护", "用户隐私保护"];

    if (userScope === 'personal') {
      return [...baseRequirements, "本地数据处理", "用户完全控制"];
    }
    if (userScope === 'small_team') {
      return [...baseRequirements, "团队数据共享安全", "访问权限控制"];
    }
    if (userScope === 'public') {
      return [...baseRequirements, "大规模用户数据保护", "合规性要求"];
    }

    return baseRequirements;
  }

  private inferProductType(summary: RequirementSummary, extractedInfo: ExtractedInfo): string {
    if (extractedInfo.productType) return extractedInfo.productType;

    const goal = summary.coreGoal.toLowerCase();
    const features = summary.mainFeatures.map(f => f.name.toLowerCase()).join(' ');

    if (goal.includes('插件') || features.includes('浏览器')) {
      return 'browser_extension';
    }
    if (goal.includes('管理') || features.includes('管理')) {
      return 'management_tool';
    }
    if (goal.includes('网站') || goal.includes('应用') || goal.includes('平台')) {
      return 'web_app';
    }

    return 'utility_tool';
  }
}
```

## 🔄 控制器

```typescript
class RequirementConfirmationController {
  private summaryGenerator: RequirementSummaryGenerator;
  private adjustmentProcessor: RequirementAdjustmentProcessor;
  private factsDigestGenerator: FactsDigestGenerator;

  async processQuestioningResult(
    questioningResult: SmartQuestioningResult
  ): Promise<RequirementConfirmationState> {
    // 1. 生成用户友好的需求总结（给用户确认界面用）
    const summary = await this.summaryGenerator.generateSummary(
      questioningResult.extractedInfo,
      questioningResult.questioningSession.answers,
      questioningResult.userInputResult
    )

    // 2. 验证总结质量
    const validation = this.summaryGenerator.validateSummaryQuality(summary)

    return {
      summary,
      validation,
      state: 'awaiting_confirmation',
      originalQuestioningResult: questioningResult
    }
  }

  async handleUserConfirmation(
    confirmationState: RequirementConfirmationState,
    userAction: 'confirm' | 'adjust' | 'restart',
    adjustments?: AdjustmentRequest[]
  ): Promise<RequirementConfirmationResult> {
    switch (userAction) {
      case 'confirm':
        return this.finalizeRequirements(confirmationState)

      case 'adjust':
        if (!adjustments) {
          throw new Error('Adjustments required for adjust action')
        }
        return this.processAdjustments(confirmationState, adjustments)

      case 'restart':
        return {
          action: 'restart_questioning',
          message: '将重新开始需求问答流程'
        }

      default:
        throw new Error(`Unknown user action: ${userAction}`)
    }
  }

  private async finalizeRequirements(
    confirmationState: RequirementConfirmationState
  ): Promise<RequirementConfirmationResult> {
    // 用户确认了简化的需求总结，现在生成事实摘要给04模块
    const factsDigest = this.factsDigestGenerator.generateFactsDigest(
      confirmationState.summary,  // 用户确认的简化总结
      confirmationState.originalQuestioningResult.extractedInfo,  // 原始提取信息
      confirmationState.originalQuestioningResult.questioningSession  // 问答会话记录
    )

    return {
      action: 'proceed_to_prd',
      // 传递给04模块的事实摘要
      factsDigest,
      // 用户确认的简化需求总结（供记录和参考）
      confirmedSummary: confirmationState.summary,
      validation: {
        confirmed: true,
        confidence: 0.95,
        timestamp: new Date()
      }
    }
  }

  private async processAdjustments(
    confirmationState: RequirementConfirmationState,
    adjustments: AdjustmentRequest[]
  ): Promise<RequirementConfirmationResult> {
    try {
      const adjustedSummary = await this.adjustmentProcessor.processAdjustments(
        confirmationState.summary,
        adjustments
      )

      return {
        action: 'show_adjusted_summary',
        adjustedSummary,
        validation: this.summaryGenerator.validateSummaryQuality(adjustedSummary)
      }
    } catch (error) {
      return {
        action: 'adjustment_error',
        error: error.message
      }
    }
  }
}

interface RequirementConfirmationState {
  summary: RequirementSummary;
  validation: ValidationResult;
  state: 'awaiting_confirmation' | 'processing_adjustments';
  originalQuestioningResult: SmartQuestioningResult;
}
```

## 输出接口

```typescript
interface RequirementConfirmationResult {
  action: 'proceed_to_prd' | 'show_adjusted_summary' | 'restart_questioning' | 'adjustment_error';

  // 传递给04模块的事实摘要
  factsDigest?: FactsDigest;

  // 用户确认的简化需求总结（供记录）
  confirmedSummary?: RequirementSummary;

  // 如果是调整，返回调整后的展示总结
  adjustedSummary?: RequirementSummary;

  validation?: {
    confirmed: boolean;
    confidence: number;
    timestamp: Date;
  };

  error?: string;
  message?: string;
}

// 用户确认界面展示的简化接口
interface RequirementSummary {
  projectName: string;
  coreGoal: string;
  targetUsers: string;
  mainFeatures: Feature[];
  technicalLevel: 'simple' | 'moderate' | 'complex';
  keyConstraints?: string[];
  userScope: 'personal' | 'small_team' | 'public';
}
```

## 与其他模块的接口

### 输入：来自智能问答模块（02模块）
- `SmartQuestioningResult`：包含ExtractedInfo、问答会话记录、完整度评估等完整数据

### 输出：传递给PRD生成模块（04模块）
- **主要输出**：`FactsDigest` - 结构化的需求事实摘要，包含：
  - 产品定义（类型、目标、用户）
  - 功能需求（核心功能、使用场景、用户流程）
  - 约束条件（技术水平、限制、平台偏好）
  - 上下文信息（痛点、解决方案、商业价值、性能要求等）

- **辅助输出**：`RequirementSummary` - 用户确认的简化需求总结（供记录和参考）

### 关键设计特点

✅ **04模块压力减轻**：接收结构化完整输入，专注PRD生成和流式输出
✅ **职责清晰**：03模块负责数据转换，04模块负责文档生成
✅ **用户体验**：用户看到简洁的确认界面，技术细节在后台处理
✅ **接口匹配**：用户确认的RequirementSummary ≠ 04模块接收的FactsDigest，职责分离清晰

## 关键特性

### ✅ **简洁明了的需求展示**
- 避免技术术语，用用户容易理解的语言
- 突出核心功能，明确优先级
- 清晰的视觉层次和交互反馈

### ✅ **灵活的调整机制**
- 支持快速修改目标、用户、功能
- 支持添加或删除功能
- 实时验证调整结果的合理性

### ✅ **质量保证**
- 自动验证需求总结的完整性和合理性
- 提供改进建议
- 确保后续PRD生成的质量
